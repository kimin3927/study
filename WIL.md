# 'WIL(What I learned)



| 순번 | 등록일자 | 내용                                                     | 완료일자  |
| :--: | :------: | :------------------------------------------------------- | :-------: |
|  1   |   8/12   | 이벤트 위임                                              |   8/15    |
|  2   |   8/13   | target, currentTarget 차이 비교                          |   8/25    |
|  3   |   8/14   | data속성 // data set // data attributes                  |   11/8    |
|  4   |   8/15   | innerText, innerHTML, textContent, text(), val(), value; |           |
|  5   |   8/16   | prototype                                                |   8/23    |
|  6   |   8/17   | 유튜브(드림코딩 - 자바스크립트 프로처럼 쓰는 팁)         |   8/18    |
|  7   |   8/18   | VS코드 들여쓰기 설정                                     |   8/26    |
|  8   |   8/19   | 속성 접근자 [ ]                                          |   8/27    |
|  9   |   8/20   | Closure                                                  |   8/28    |
|  10  |   8/21   | 비동기                                                   |   8/29    |
|  11  |   8/22   | 프로미스                                                 | 9/6미완료 |
|  12  |   8/23   | 인스턴스                                                 | 9/6미완료 |
|  13  |   8/24   | class                                                    | 9/6미완료 |
|  14  |   8/25   | git                                                      |           |
|  15  |   8/26   | npm                                                      |           |
|  16  |   8/27   | node.js                                                  |           |
|  17  |   8/28   | 모듈                                                     |           |
|  18  |   8/29   | Component                                                |           |
|  19  |   8/30   | 객체지향                                                 |           |
|  20  |   8/31   | DOM                                                      |    9/6    |
|  21  |   9/1    | 구조분해할당                                             |    9/4    |
| 22/  |   9/2    | SEO                                                      |    9/8    |
|  23  |   9/4    | 함수표현 형태(화살표 함수 등)                            |    9/6    |
|  24  |   9/5    | then                                                     |           |
|  25  |   9/6    | for of, for in 비교                                      |    9/5    |
|  26  |   9/7    | grid                                                     |    9/7    |
|  27  |   9/8    | 미디어쿼리                                               |   9/11    |
|  28  |   9/9    | CSS 가상 셀렉터(hober,active, focus)                     |   10/06   |
|  29  |   9/10   | CSS transperation                                        |           |
|  30  |   9/11   | Object 메서드                                            |   9/15    |
|  31  |   9/12   | CSS Flex                                                 |   9/11    |
|  32  |   9/15   | position                                                 |   9/21    |
|  33  |   9/16   | !important                                               |           |
|  34  |   9/13   | BEM                                                      |           |
|  35  |   9/15   | 태그 <i>                                                 |   11/1    |
|  36  |   9/16   | Ajax                                                     |   9/16    |
|  37  |   9/17   | CORS                                                     |   9/17    |
|  38  |   9/18   | response 객체                                            |           |
|  39  |   9/19   | status 코드                                              |   9/19    |
|  40  |   9/20   | Single Page Application                                  |           |
|  41  |   9/21   | Pjax                                                     |           |
|  42  |   9/22   | ECMA                                                     |           |
|  43  |   9/23   | Babel                                                    |           |
|  44  |   9/24   | Jquery : DOM Insertion, Inside                           |           |
|  45  |   9/25   | svg                                                      |   11/10   |
|  46  |   9/26   | Jquery - Event Object                                    |           |
|  47  |   9/27   | dir                                                      |           |
|  48  |   9/28   | 정규표현식                                               |   9/28    |
|  49  |   10/4   | box-sizing속성                                           |           |
|  50  |   10/5   | px vw 등 단위별 특징 비교                                |           |
|  51  |  10/11   | firebase                                                 |           |
|  52  |  10/11   | 구글클라우드플랫폼                                       |           |
|  53  |  10/23   | XMLHttpRequest                                           |           |
|  54  |  10/24   | animate                                                  |   10/24   |
|  55  |  10/25   | CSS:transition                                           |   10/25   |
|  56  |  10/26   | fileReader 객체                                          |   10/26   |
|  57  |  10/27   | native method, sort()                                    |   10/27   |
|  58  |  10/31   | HTML태그: `label`                                        |   10/31   |
|  59  |   11/2   | CSS: 가상엘리먼트 : after, : before                      |   11/2    |
|  60  |   11/3   | error 객체                                               |           |
|  61  |   11/4   | throw, try, catch                                        |           |
|  62  |   11/8   | 태그: xmlns                                              |   11/8    |
|  63  |   11/8   | scss                                                     |           |
|  64  |   11/9   | 위도와 경도로 두 지점간의 거리구하기                     |   11/9    |
|  65  |  11/11   | CSS: vertical-align                                      |           |
|  66  |          | div에 a태그를 덮을경우의 에러                            |           |
|  67  |  11/12   | sheetJs                                                  |           |
|  68  |  11/13   | CSS: @keyframes animation                                |           |
|  69  |  11/13   | CSS: transform                                           |           |
|  70  |  11/14   | CSS: transition                                          |           |
|  71  |  11/21   | 좌표 값 찾기                                             |           |
|  72  |   12/1   | 날씨어플 만들기                                          |           |
|  73  |   12/5   | todo manager만들기                                       |           |
|  74  |  12/10   | vue.js                                                   |           |
|  75  |  12/20   | .find() 메서드                                           |           |
|  76  |  12/21   | 즉시실행함수                                             |           |
|  77  |          |                                                          |           |
|  78  |          |                                                          |           |
|  79  |          |                                                          |           |



## 1.이벤트 위임(Event Delegation)

이벤트위임이란, **상위 노드에서 하위 노드의 이벤트를 제어** 하는 방식이다.

이벤트 위임을 위한 코드는 매우 간단하다. 화면의 모든 `li`에 이벤트 리스너를 추가하는 대신 **`li`의 상위 요소인 `ul` 태그에 이벤트 리스너를 연결** 하고, **하위에서 발생한 클릭 이벤트를 감지** 하는 것이다.[출처](https://frontsom.tistory.com/13)

이벤트 위임이 발생하는 원리를 살펴보면, 자식 요소에서 발생한 이벤트가 부모 요소로 전파되는 **이벤트 버블링**[^1]을 이용한 것을 알 수 있다.

** 이벤트 버블링 : 



- ##### 이벤트 위임의 이점 [^2]

  1. 동적인 엘리먼트에 대한 이벤트 처리가 수월하다.

  2. 상위 엘리먼트에서만 이벤트 리스너를 관리하기 때문에 하위 엘리먼트는 자유롭게 추가 삭제할 수 있다.

  3. 이벤트 핸들러 관리가 쉽다.

     - 동일한 이벤트에 대해 한 곳에서 관리하기 때문에 각각의 엘리먼트를 여러 곳에 등록하여 관리하는 것보다 관리가 수월하다.

  4. 메모리 사용량이 줄어든다.

     - 동적으로 추가되는 이벤트가 없어지기 때문에 당연한 결과이다. 1000건의 각주를 등록한다고 생각해보면 고민할 필요로 없는 일이다.

     - 메모리 누수 가능성도 줄어든다.

     - 등록 핸들러 자체가 줄어들기 때문에 메모리 누수 가능성도 줄어든다.

  

- ##### **주의사항**

  이벤트 위임이 필요 없는 하위 요소에 대한 별도 처리가 필요함



- ##### 추가학습 필요사항

  연습, 예시코드 작성

  버블링이 아닌 캡처링으로 할 경우 작동이 안되는 것인지?
  
  td에 대한 Event바인딩을 table에 위임하고 싶은데, 안됨 

## 2.target, CurrentTarget 차이비교

이벤트가 위임되는 경우, 하위객체는 event 



event.target = 이벤트가 발생한 '정확한' 위치.  

event.currentTarget = 해당 이벤트가 '설치된' 요소.



예시 1) button태그와 button태그 내부에 텍스트를 담당한 span태그의 경우 

   - 해당 버튼을 클릭했을 때, 
        - target : span
        - currentTarget : button 

예시 2) body태그에 addEventListener를 달아 "click"을 인식하게 했다. <body> 하위에는 <div> 태그를 위치시켰다.

   - 해당 화면 클릭 시
        - target : div (클릭한 자리의 최하단위)
        - currentTarget : body (addEventListener가 붙은 자리)



즉, event.target은 부모로부터 이벤트가 위임되어 발생하는 자식의 위치, 내가 클릭한 자식 요소를 반환한다. 하지만 currentTarget은 이벤트가 부착된 부모의 위치를 반환한다.



## 3. data속성 / dataset / attribute 

1. data 속성(dataset 메서드)

data 속성은 사용자가 임의로 DOM 요소에 저장시킬 수 있는 속성으로서, 

data-로 시작시켜서 이름을 지을 수 있고, 여러개를 쓸 수 있다. (ex: data-columns, data-index, )

속성이지만, 해당 속성에 접근하기 위한 별도의 메서드를 갖고 있다. 

일반 속성용 : setAttribute & getAttribute  // 사용예 : element.setAttribute( 'name', 'value' )

data 속성용 : dataset

- 문법 

  ```
  1. 자바스크립트
  const myDiv = document.getElementById('myDiv');
  
  myDiv.dataset.kimin = "3" // HTML #myDiv에 data-kimin 속성의 value가 "3"으로 저장됨
  myDiv.dataset.kimin; // 3이 return
  myDiv.dataset.kimin = "5" // HTML #myDiv에 data-kimin 속성의 value가 "5"로 갱신됨
  
  2. Jquery
  $("#myDiv").data("kimin", 3) // setAttribute; 
  $("#myDiv").data("kimin") //getAttribute;
  $("#myDiv").removeData("kimin") // delete;
  ```

2. attribute 

   getAttribute;

   d

   

## 4. innerText, innerHTML, textContent  등등 비교



1. 자바스크립트

   DOM.textContent = str

   DOM.innerHTML = str

   DOM.innerText = str

   

2. Jquery

   ### $("셀렉터").html()

   **셀렉터태그내에 존재하는 자식태그을 통째로 읽어올때 사용되는 함수**

   **※ 태그 동적추가할때 주로 사용되는 함수**

   

   ### $("셀렉터").text()

   **셀렉터태그내에 존재하는 자식태그들 중에 html태그는 모두 제외 한 채 문자열만 출력하고자 할때 사용되는 함수**

   **※ html태그까지 모두 문자로 인식시켜주는 함수**

   

   ### $("셀렉터").val()

   **INPUT 태그에 정의된 value속성의 값을 확인하고자 할때 사용되는 함수**

   





## 5. prototype



prototype은 속성의 하나로서, 함수는 기본적으로 갖고있는 속성이다. 

객체 형식으로 구성되어 있으며, 각 함수가 생성자 함수로 실행될때 특별한 역할을 하도록 설계되어 있다. 

* 조회방법 console.log(someFunction.prototype); 

* 해당 객체에는 함수명부터가 저장이 되어 있기 때문에 실행내용이 동등한 함수라고 해도 kimin.prototype === kimin1.prototype 의 결과는 false이다. 

그래서, 함수가 무조건 내장하고 있는 속성 prototype을 통하면, 아직 실행한 바 없는 생성자 함수를 예견(?)하여 생성 예정인 해당 객체의 속성을 준비(?)시킬 수 있다. 

<원래 순서>

1. function kimin(a,b){ return a + b; }
2. const kimkimin = new kimin; // key도 ,value도 없는 빈 객체  kimin이 생성됨, kimkimin으로 명명됨
3. kimkimin.name = "김기민"; // 빈객체 kimin에 name이라는 key와 김기민이라는 value가 부여됨..



<prototype속성을 활용하는 상황속에서의 순서>

1. function kimin(a,b){ return a + b; }

2. kimin.prototype.name = "김기민"; 함수 kimin에 name이라는 key와  김기민이라는 value가 부여됨. 

3. const kimkimin = new kimin  //  key도 ,value도 없는 빈 객체  kimin이 생성됨, kimkimin으로 명명됨

   ** 다만, 이 때의 kimkimin은 prototype key "name"과 해당 value "김기민"을 갖고 있음. 

   ** 또한, kimkimin.name을 출력하면 정상 "김기민" 나옴. 

   ** 즉, kimin.prototype.name => kimkimin(new kimin).name으로 활용됨. 



![image-20210823223458263](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20210823223458263.png)

위 이미지 기준, 

함수 = 예시상의  *f*, kimin ;

인스턴스 객체 = new kimin을 통해 생성된 *object* kimin ;

프로토타입 객체 = kimin.prototype.name ;

** 켄님의 비유 : 자식(인스턴스 객체)는 해당 속성이 없을 경우 엄마(프로토타입 객체)의 속성을 빌려 쓸 수 있다. 



Object.create(something) : something을 프로토타입으로 삼는 메서드임.

따라서, 

const Kimin = Object.create(something); Kimin은 something 을 프로토 타입으로 갖는 빈 객체인 것. 

응용 ,



Human.prototype = Object.create(Animal.prototype) ;  // Human의 prototype으로 Animal 의 prototype을 취함. //다만 prototype을 넣는 과정에서 아래 처리가 요구됨

Human.prototype.constructor = Human; 





## 6.자바스크립트 프로처럼 쓰는 팁

#### 1. Ternary Operator(3항 조건 연산자, ?) 적극 활용

true에 a를 반환 false에 b를 반환하는 2가지 경우의 수를 지닌 간단한 if문이라면 3항 연산자 '?'의 활용이 낫다.

개선 예시) 변수 x를 받아 양수/음수여부를 return하고자 할 때,

**if문 사용 시:**

```
function calculateNumber(x){
    if(x > 0) {
        return "양수";
    } else{
        return "음수";
    }
}
```

 **3항 연산자 사용 시:**

```
function calculateNumber(x){
    return a > 0 ? "양수" : "음수"
}
```



#### 2. nullish-coalescing operator(??) 적극활용

'??' : nullish-coalescing[^3] operator라고 하며, leftCode가 <u>null 이거나 undefined인 경우</u>, 오른쪽 code를 실행하게 한다.[^4]

개선 예시) 매개변수 text를 받아 console.log를 해야하는 데, text가 null이거나 undefined인 상황에 에러메세지를 출력하고자 할 때,

**if문 사용 시:**

```
function printMessage(text){
	const message = text;
	if(text == null || text == undefined){
		message = "nothing to display";
	}
	console.log(message);
}
```

**'??' 사용 시:**

```
function printMessage(text){
	const message = text ?? "nothing to display";
	console.log(message);
}
```

* 부가소개: Logical OR operator '||'

  * '??' 과 유사하게 좌변을 평가하여 우변을 실행함
  * 다만 '??'가 nullish여부를 평가하는 반면 '||'는 falsy여부로 평가함.
  * 즉 차이점은 '??'(nullish평가)가 'undefined'와 'null'만 판단하는 반면 '||'는 0,"" 역시  조건에 포함됨.

  

#### **3. Object Destructuring**

객체를 다룰 때, value에 접근하기 위한 과정을 Object Destructing을 활용하여 단축할 수 있다. 

개선 예시) name: kimin, age: 8, grade: 1을 가진 object person에 대해서, 해당 value를 활용하는 함수를 만들 때,

**단순하게 접근할 경우:**

```
function displayPerson(person){
	console.log(`${person.name}의 나이는${person.name}이다. 그래서 ${person.name}의 현재 학년은 초등학교 ${person.grade}학년 입니다.)
}
```

**Object Destructuring 사용 시:**

```
function displayPerson(person){
	const { name, age, grade} = person;
	console.log(`${name}의 나이는${age}이다. 그래서 ${name}의 현재 학년은 초등학교 ${grade}학년 입니다.`)
}
```



#### 4.Spread Syntax

Spread Syntax는 기존 object 를 활용하여 새 object를 만드는 데 쓸 수 있는 방법이며, 특히 복수의 object 통합하는데 쓸 수 있다.

'...'을 활용하는 방법이다. 

개선 예시) 2개의 object를 통합할 경우, 

object1 = { name: "kimin", age: 8, grade: 1}

object2 = { hobby: "golf", natinonality: "Korea"}

**단순하게 접근할 경우:**

```
const object3 = {}
object3.name = "kimin";
object3.age = 8;
object3.grade = 1;
object3.hobby = "golf";
object3.nationality = "Korea";
```

**Spread Syntax 사용 시:**

```
const object3 = {...object1,...object2};
```

***내장함수 사용 시:**

```
const object3 = Object.assign(object1,object2};
```

* 한편, spread syntex는 객체뿐 아니라 배열에서도 사용할 수 있는데, 

  기존 배열을 변경하여 신규 배열을 만들게 되는데, 예시는 아래와 같다. 

  ```
  const fruitsArray = ["사과","딸기",배]
  const fruitsArray = [...fruitsArray,배] >> 기존 배열에 배를 push시킴 
  const fruitsArray = [...fruitsArray, ...anotherArray] >> 기존 배열에 또다른 배열을 concat시킴 
  ```

  

#### 5.Optional Chaining

optional chaining은 자바스크립트 문법의 하나로서 '?.'라는 기호를 통해 사용된다. 

object를 객체로서 사용하는데, someObject?.somePropery 라는 구조속에서, 해당 Object가 존재하면 해당 property를 반환하고, 존재하지 않으면, undefined를 반환함. 

활용 예시) 인사정보(배열)은 인물별로 객체화 되어있음 & user.address.street를 반환해야 함. 그런데 기입 누락으로 일부 인원은 adress가 누락됐을 수도 있는 상황

const HRdatas = [ 

​	{name: "kimin", 

​	adress: { city: "Seoul", street: 1234}},

​	{ name: "jimin"}

]

**단순하게 접근할 경우:**  

```
HRdatas[x].address.street; // 모든 정보가 없는 jimin의 케이스에서 에러 발생

그래서, 아래와 같이 조건을 길게 써야함
if(HRdatas[x] && HRdatas[x].address && HRdatas[x].address && HRdatas[x].address.street){
	HRdatas[x].adress.street);
}  // 조건이 미충족될 경우 undefined;
```

**Spread Syntax 사용 시:**

```
HRdatas[x]?.address?.street // undefined;
```

* 프로퍼티에 안전하게 접근(존재하지 않다고 에러를 내지 않고, '존재하지 않는다'고 평가가능)



#### 6.Template Literals

변수와 문자열을 합해서 쓰기위해 편한 방법(Back tic , 사용법)

**단순히 접근 시 :**  

```
function sayHello(x,y) {
	console.log("안녕하세요"+x+"씨"+y+"씨와 방문해주셔서 감사합니다.");
};
```

**Template Literals 사용:**

```
function sayHello(x,y) {
	console.log(`안녕하세요 ${x}씨${y}씨와 방문해주셔서 감사합니다.`);
};
```



#### 7.Loop에서 배열 API 적절히 활용하기 

아래의 배열 API를 숙지, 적절히 활용할것

- Array.filter(f): 필터에 return 함수를 넣고, 조건에 해당하는 인자로 구성된 배열을 return 한다. 

  ```
  const arr = [1,2,3,4,5,6];
  arr.filter(function (x) {return x > 3}); /// [4,5,6]
  ```

- Array.map(f)[^5 ]: 배열의 각 인자에 특정 함수를 매핑시켜  해당 결과값으로 구성된 배열을 return 한다. 

  ```
  const arr = [1,2,3,4,5,6];
  arr.map(function (x) {return x + 1}); /// [2,3,4,5,6,7]
  ```

- Array.reduce(f(x,y), Initial Value): f(x,y)는 콜백함수이며, Initial value는 콜백의 첫번째 호출값인데, 생략할경우 Array의 첫번째 인자가 Initial Value의 Default value이다. 

  콜백함수는 모든 인자에 대해 순서대로 불러들여 값을 계산하고, 회차별 값은 누적되어 최종적으로 전 인자가 callback 함수에 적용됨.

  콜백함수의 첫번째 인자는 accumulator를 의미(매번 값을 누적시키는), 두번째 값은 현재값(대상 Array의 각 인자)로 구성된다. 

  즉 reduce는 Array[0]~Array[Array.length-1]를 순차적으로 콜백함수에 적용시키는 것이다. 

  ```
  const arr = [1,2,3,4,5,6];
  const sum = arr.reduce(function (pre, value) {
      return pre + value;
  });
  
  // pre + arr[1] // pre = 3
     pre + arr[2] // pre = 6
     pre + arr[3] // pre = 10
     pre + arr[4] // pre = 15
     pre + arr[5] // pre = 21
  console.log(sum); // 21
  ```

활용 예시)  arr = [1,2,3,4,5,6]이 있을 때, 짝수인 경우에 &4를 곱하고&총합을 구하려고 할때. 

**단순히 접근 시 :**  

```
const arr1 = []
for(let i = 0; i < 6; i++){
	if(arr[i] % 2 === 0){
		const item = arr[i]*4
		arr1.push(item);
	}
}
const length = arr1.length
let sum = 0;
for(let i = 0; i < length; i++){
	sum += arr1[i]
} // 48
```

**배열 API 사용 시:**

```
const result = arr
	.filter((x) => x % 2 === 0)
	.map((x) => x * 4)
	.reduce((a,b) => a + b, 0);
console.log(result); // 48
```

** 적절한 API의 활용으로 for문을 생략할 수 있어 코드가 짧아졌고, 의미도 쉽게 눈에 들어옴. dot Notation을 적절히 활용할 수 있었음



#### 8.Async · Await(promis 몰라서 순연)

<div style=text-align:right>- 끝 -</div>



## 7. VS코드 들여쓰기 설정

1. 탭사이즈 확인

   - 기본화면 우하단 UTF-8 좌측에 1탭이 몇 space인지 적혀있음

2. 탭사이즈 설정

   1. 탭사이즈 세팅하기 

      메뉴에서 File > Preferences > Settings 클릭한다.

       **Editor: Tab Size**에서 원하는 크기 입력한다.

      

3. 편집 중 엔터 줄바꿈 시,



<div style=text-align:right>- 끝 -</div>

## 8. 속성 접근자 [ ] 

- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Property_Accessors



**속성 접근자**란, 객체의 key에 접근하거나 method를 적용할 때 쓰는 것으로 보통은 마침표 . 을 사용하는 그것이다.

```
예시) 
const person = {name : "김기민", age : "30"}
person의 name에 접근 =>> person.name ; // "김기민"
```

그런데 내가 몰랐던 다른 방법이 있었으니, 대괄호 사용법이다. 

```
예시) 
const person = {name : "김기민", age : "30"}
person의 name에 접근 =>> person["name"] ; // "김기민"
```

대괄호 사용법을 꼭 알아야 하는 이유는, key에 기호가 들어가 있을 경우 .을 사용할수가 없다. 

속성접근자 .은 기호를 받지 않기 때문이다. 

```
예시) 
const person = {".name" : "김기민", ".age" : "30"}
person의 .name에 접근 =>> 
1. .을 사용해서 접근 : person.".name" //Error: Unexpected string
2. []를 사용해서 접근 : person[".name"] ; // "김기민"
```

.사용이 훨씬 편해보여서 책에서 []를 봤을 때도 그냥 지나쳤는데,

key에 class를 집어넣어서 활용하는 코드를 보게 되어 []접근법을 숙지해야 겠다는 생각을 했다.  

<div style=text-align:right>- 끝 -</div>





## 9. Closure

클로저(closure)는 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 가르킨다. 

위 표현만으로는 와닿지 않는데, '내부함수가 외부함수의 맥락에 접근하는 상황'이란 아래와 같은 상황을 말한다고 한다.

```
예시 1.
function factoryMovieName(title) {
	return {
    	getTitle: unction(){
			return title;
		},
		setTitle: function(_title){
			title = _title;
		}
	}
}

/*
1. factoryMovieName은 객체를 생성하는 함수이다. 
2. 위 함수에 인자"김기민"을 넣어 변수 kimin에 할당하면 두개의 함수를 가진 아래 객체를 반환한다. 
const kimin = factoryMovieName("김기민");
{ getTitle = function(){return 김기민;},
  setTitle = function(_title){title = _title} }
3.위 상황속에서 객체 kimin에 첫번째 methiod를 실행하면,
 kimin.getTitle(); // 김기민 returned
4.그러나 두번째 method를 인자 "기민"을 사용해 실행하면,
 kimin.setTitle("기민"); // title에 "기민"이 할당됨
5.setTitle이후에 다시 첫번째 method를 실행해보면,
 kimin.getTitle(); // 기민 returned

>> 
factoryMovieName과 getTitle&setTitle의 관계는 '외부함수'와'내부함수'임.
외부함수에서 주어진 title이란 변수로 만들어진게 객체 kimin인데,
내부함수 setTitle을 쓰면 외부함수에서 부여한 변수 title이 변경되고 있음
즉, 내부함수가 외부함수의 맥락(context)에 접근하고 있음
이 상황을 외부함수와 내부함수에 closure 관계가 있다...라고 하는 듯함. 
```



- 의문사항

  그렇다면, closure는 이러한 특정 현상/기법을 말하는 것인가?? 

  Closure 라는 단어와의 연관성도 느껴지지 않고,

  해당 단어의 쓰임이 궁금하다. 가령, 아래와 같이 단어를 용도에 맞게 표현해야할텐데,

  ```
  메서드를 -> 쓰다
  변수를 -> 할당하다
  이벤트리스너를 -> 쓰다. 
  캡슐화 -> 했다.
  closure를 -> 썼다? 
  closure가 -> 있다? 
  ```

## 10. 비동기

동기 synch (synchronous) : 일반적인 자바스크립트 실행 방식

비동기 asynch : 일부, 비동기 함수에서의 실행 방식



setTimeout(web API), fetch(?) 등은, 자바스크립트 외부의 엔진(?)에 요청사항을 전달 한 후, 콜백 함수를 활용하는 함수인데, 외부 엔진에 접근하는 함수들의 경우는 비동기원칙에 따라, 외부요청결과를 기다리지 않고 자바스크립트 내부 함수를 우선한다. 

때문에, 잔여 실행 사항을 완료한 후에야 외부엔진 요청사항의 결과를 반영하여 최종 실행이 된다. 

이런 식으로 비동기 함수는 스스로의 완료를 기다리지 않게 하기 위해, 다른 함수와 병렬적(?)으로 함수를 실행시킨다. 



## 11. 프로미스

자바스크립트에서 제공하는 비동기처리를 쉽게하게 하기위한 Class(object)임

기능수행의 성공/실패에 따라 성공시 기능, 실패시 에러전달. 식으로  기능함

프로미스 이해 포인트

1. 상태이해 (프로세스의 해당 오퍼레이션 수행여부가 수행중인지, 완료인지(fulfilled || rejected)
2. Producer와 Consumer의 차이점 이해 

프로미스 예시

1. 프로미스는 클래스이기 때문에, 생성자 함수로 객체를 만들 수 있다.

2. 프로미스 생성자 Promise는 executer(콜백함수)를 필요로 한다.

   - executer는 아래 2개의 콜백함수로 구성되어 있다. 

   1. 정상 수행시에 활용될 함수 resolve(사실상 return인듯)
   2. 기능 수행에 문제가 생겼을 때 호출할 함수 reject
      - 그래서, pomise 생성은 아래 형식과 같이 수행된다. 
      - 

3. 프로미스는 생성즉시 executer를 수행한다.  

   => 그렇기 때문에, 불필요한 통신이 일어나지 않도록 감안해서 작성해야한다. 



- state : pending -> 

- producer(즉 promise)

  const promise =new Promise(executer)

- consumer 

  promise 수행이후의 연결 동작을 의미하는 듯 

  const kimin = new Promis((resolve, reject) =>{})의 상황에서, 

  consumer는. 

  kimin.then((x)=> {})라는 식으로 활용하면 된다. 

  ​	.then: resolve 값에 따라 함수적용

  ​	.catch(error =>{})에러에 따라 함수 적용

  ​	.finally(()=>{}) 성공하든 실패하든 함수적용

- async, await

  => Promise를 더 간편하게, 깔끔하게 쓸 수 있게 해줌, 동기화처럼 보여주게 함. 

  => 그냥 .then.then하면 너무 길어져서 가독성이 떨어질 수 있음

  (syntactic sugar, 완전 새로운 건 아니고 기존 존재하는 api를 발전시켜주는 문법도구)

  1. async 문법 

     async function kimin(){}; 

     ```
     1. Promise만 쓸경우
     
     fucntion fetchUser(){
     	return new Promise((resolve, reject) => {
     		resolve(userID);
     	}
     }
     const user = fetchUser();
     user.then(console.log(user));// user.then(console.log)로 생략가능
     
     2. async 활용 시,
     
     async function fetchUser(){  // async 키워드가 자동으로 해당 함수를 promise로 바꿔준다
     	return userID;
     }
     
     const user = fetchUser();
     user.then(console.log);
     
     ```

  2. await 

     await은 async 함수 내부에서만 쓸 수 있음 

     함수내부에서, await을 걸면 await함수의 작업완료까지 다음 실행을 지연함

     ```
     function delay(ms){
     	return new Promise((resolve) => {setTimeOut(resolve, ms)})
     }
     
     1. await 비사용 시, 
     
     function getBanana(){
     	return delay(3000).then(() => {return banana})
     }
     
     2. await 사용 시,
     
     async function getBanana(){
     	await delay(3000);
     	return banana;
     }
     ```

     

- Promise.all:복수의 promise를 병렬 처리 하기 위해 생기는 문제를 간편히 해결하기 위해 promise 배열을 위한 promise의 api이다.

  ```
  아래 case는 2개의 비동기 함수 getApple과 getBanana를 await해서 한번에 pickAllFruits를 실행하는 내용이다. 
  
  async function getApple(){
  	await delay(1000)
  	return apple;
  }
  
  async function getBanana(){
  	await delay(1000)
  	return banana;
  }
  
  async function pickAllFruits(){
  	const apple = await getApple();
  	const banana = await getBanana();
  	return apple + banana;
  } // 다만, 위 경우에서 apple과 banana는 병렬 처리를 하는게 이로운데 굳이 2초를 소모중이다.
  
  위의 식을 병렬처리하여 1초만에 완료시키기 위해서는 
  1. Promise.all 비사용할 경우, 
      async function pickAllFruits(){
          const applePromise = getApple();
          const bananaPromise = getBanana();
          const apple = await applePromise
          const banana = await bananaPromise
          return apple + banana;
      } // 이렇게 하면 1초만 소요됨 
  
  2. Promise.all 사용 시, 
  
  function pickAllFruits(){
  	return Promise.all([getApple(),getBanana()]).then((fruits) =>{fruits.join('+');})
  } // Promise.all은 변수로 promise들의 배열을 받아서, 각 promise들을 비동기 처리하고,
  다 완료되면 함수를 수행시키는 api이다. 
  즉, 모든 promise들이 병렬적으로 처리하여 모아주는 것이다. 
  ```

  - Promise.race() : 역시 Promise 의 api 로서, promise들의 배열을 변수로 받아서

    먼저완료된 promise를 return한다. 

## 12. 인스턴스



**생성자 함수가 반환해주는 빈 객체는 흔히 Instance(인스턴스)라고 부릅니다.**





## 13.Class

"자바스크립트는 실제 클래스 기능을 지원하지 않는다. 대신 *모조 클래스* 를 정의."

> 모조 클래스 = 프로토타입 객체 or 생성자 함수를 사용하여 구현 가능

-> **클래스는 다른 언어에서 존재했던 기능이고 자바스크립트에서는 사후에 지원하게 된 기능이다.**

(자바, python,php 등에서 객체생성 함수(?)로서 쓰던 문법이었음.) 

자바스크립트 ES6에서, 자바스크립트에서도 객체지향을 구사하기 위해 Class 문법을 추가함. 

constructor의 대체제라고 보면됨.



*"클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태(멤버 변수)와 메서드(함수)로 구성된다.*

-> **새로운 객체를 생성하는데에는 const ~~~ = {}; new + 대문자 함수면 충분한 줄 알았는데 아닌 듯 하다.**

"어떤 사람들은 `class`라는 키워드 없이도 클래스 역할을 하는 함수를 선언할 수 있기 때문에 `클래스`는 '편의 문법’에 불과하다고 이야기합니다. 참고로 기능은 동일하나 기존 문법을 쉽게 읽을 수 있게 만든 문법을 편의 문법(syntactic sugar, 문법 설탕)이라고 합니다. **그러나 편의문법이 아니다.**"

```
class 없이 같은 역할을 하는 함수를 선언하는 예시)

// 1. 생성자 함수를 만듭니다.
function User(name) {
  this.name = name;
}
// 함수의 프로토타입은 'constructor' 프로퍼티가 Default라서, 명시적으로 constructor를 만들필요 없음

// 2. prototype에 메서드를 추가합니다.
User.prototype.sayHi = function() {
  alert(this.name);
};

// 사용법:
let user = new User("John");
user.sayHi();

```



## 14. git

## 15. npm

"node로 프로젝트를 진행할 때 많이 쓰이는 패키지 관리 툴로는 대표적으로 **npm과 yarn**이 있습니다."

"Node.js로 만들어진 모듈을 웹에서 받아서 쉽게 설치하고 관리해주는 프로그램으로 개발자 입장에서는 단 몇 줄의 command로 기존 공개된 모듈들을 설치하고 활용할 수 있습니다."

"npm이 없었을 때에는 필요로 하는 기능을 추가하기 위해서 직접 작성하거나 github를 통해 다운로드하여 사용해야 했습니다. 이러한 불편을 해소하기 위해 나타났으며, Node.js를 설치하기만 하면(기본적으로 npm은 Node.js 내에 내장되어 있습니다) 명령어 한 줄로 기능의 추가가 가능합니다."



## 16. 생활코딩 : node.js

2009년 Ryan dahl이라는 사람이 node.js프로젝트를 했고,

구글의 V8 엔진 + Event Driven이라는 JS의 개발방식 + non-blocking IO라는 입출력방식

를 결합한 것으로, 웹브라우저에서만 동작하는 javascript를 서버에서도 동작하도록 확장을 시킨..프로그래밍 언어이다.

|  Language  |  Run Time   | 비고                    |
| :--------: | :---------: | ----------------------- |
| Javascript | Web Browser | 브라우저 필요, 콘솔사용 |
| Javascript |   Node js   | 불필요, 터미널사용      |



1. files system 

   파일을 읽고/쓰고 하는 등의 기능

   ```
   var fs = require('fs');  // file system 모듈을 import, node가 깔려있어서 별도의 준비작업이 불필요한듯함 (통신이 되는?)
   
   fs.readFile("파일경로", 'uft8', 콜백함수)
   
   fs.readFile('./sample.txt', 'utf8', (err, data) => {
       if(err) throw err;
       console.log(data)
   })
   ```

   

2. process.argv

3. 파일목록 알아내기

   ```
   fs.readdir("../node/", function(err, fileList){
       console.log(fileList)
   })
   ```

4. 함수를 이용해서 정리정돈하기

    



## 17. 모듈

## 18. 컴포넌트

## 19. 객체지향

OOP : Object Oriented Programing , 프로그래밍 패러다임, '로직을 상태와 행위로 이루어진 객체로 만드는 것이다. '

<객체지향 프로그래밍 개념의 필요성>

1. 웹이 복잡해지면 함수 로직의 복잡성으로 관리가 어려움
2. 기능별로 분류하여 체계적으로 관리할 필요가 있음
3. 기능별, 로직별로 구획화하여 관리하기에 용이한 형태가 '객체'라는 데이터 타입이며



{절차지향프로그래밍?}



## 20. DOM



BOM : 브라우저객체 모델 - 브라우저(윈도우) 구성에 대한 설명, 원칙

DOM : 문서객체모델 - document 구성에 대한 설명, 원칙



DOM은 노드로 구성되어 있고, Tree형식으로 되어 있다. 

문서를 트리모양의 노드집단으로 정의하는 것이 문서객체 모델이다. 





## 21. [구조분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

"**구조 분해 할당** 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다."

= 배열이나 객체에 대하여, 그 내부 값을 사용하는데 도움을 준다. 

```
예시1)
//기본 표현식
const a = 1;
const b = 1;

//구조분해할당 표현식
const [a,b] = [1,2] 

예시2) 구조분해할당 표현식 응용
let anObject = {1:"a", 2:"b", 3:"c", 4:"d"};
for (const [key, value] of Object.entries(anObject)) {
  console.log(`${key}: ${value}`);
} 

// "a: somestring"
// "b: 42"

예시3)
const object = { a: 1, b: 2 };
const { a, b } = object;
console.log(a); // 1
console.log(b); // 2

```





## 22. SEO

"**검색 엔진 최적화**(search engine optimization)으로부터 웹사이트나 웹페이지에 대한 웹사이트 트래픽의 품질과 양을 개선하는 과정이다.2019년도 이후로 한국 내 구글의 점유율이 30%를 넘어서고 있고, 네이버의 점유율이 점점 하락 하고 있으며, 구글은 네이버와같은 블로그 우선노출과 같은 정책이 없고 구글 애즈를 제외한 다른 검색결과에 한해서는 검색엔진 최적화 여부에 따라 웹사이트를 랭킹 시키고 있기 때문에 검색엔진 최적화(SEO)의 중요성이 점점 부각되고 있는 실정이다."

SEO 최적화를 위한 가이드 예시

- ##### Google 및 사용자가 내 콘텐츠를 이해할 수 있도록 돕기(구글 검색센터 참조)

  - 고유하고 정확한 페이지 제목 만들기(header, title 설정을 통해)
  - `description` 메타 태그를 사용합니다
  - 표제 태그를 사용하여 중요한 텍스트 강조하기
  - [구조화된 데이터 마크업 추가하기](https://developers.google.com/search/docs/advanced/structured-data/sd-policies?hl=ko)(schema?)

- Semantic HTML

  "시맨틱 HTML은 페이지 DOM 구조에서 의미가 있는 HTML 요소를 사용하는 것입니다. Semantic HTML을 사용하면 웹 사이트 및 웹 페이지의 일부를 기능에 따라 코딩할 수 있습니다. Search Engine Crawlers는 Semantic HTML 요소를 인식할 수 있으므로 웹 페이지의 관련 부분을 더 빨리 인식하여 더 적은 비용으로 검색 의도를 충족하는 비율을 계산할 수 있습니다."
  - 주요 태그

    1. Meta Description

    2. Heading(ex h1)

    3. title

    4. alt 

    5. 그 외

       `<article>` for standalone content pieces such as articles or reviews,
       `<section>` to mark up other content blocks that logically belong together, for instance tabbed content,
       `<aside>` for sidebars,
       `<nav>` for navigation sections.

       그 외에도 headings `<h1>, <h2>, <h3>, <h4>, <h5>, <h6>` , ordered and unordered lists `<ol>, <ul>, <li>`, paragraphs `<p>`, images `<img>`, tables `<table>, <thead>, <tbody>, <tfoot>, <tr>, <td>`, form elements `<form>, <fieldset>, <label>, <input>, <textarea>`, and links `<a>`가 시맨틱 요소에 해당한다.

## 23. 함수 표현 형태(화살표 함수 등)

- 기본형태

  (...args) =>  experession; 

  ```
  예시)
  <기본 표현>
  function add(a,b) {
  	return a + b;
  }
  
  <화살표 함수>
  const add = (a, b) => a + b;
  ```

- 변수가 1개뿐일 땐 소괄호도 생략 가능

  ```
  예시)
  <기본 표현>
  function multiply(a) {
  	return a * 3
  }
  
  <화살표 함수>
  const multiply = a => {return a * 3};
  ```

- 다만 표현식에 줄바뀜이 필요할 경우(여러줄인 경우) (1)중괄호로 묶고, (2) return 표기 필요

  ```
  예시)
  <기본 표현> 
  function add(a,b) {
  	let result = a + b;
  	return result;
  }
  <화살표 함수> 
  const add = (a, b) => {
  	let result = a + b;
  	return result;
  }
  ```

## 24.then



## 25. for of / for in 비교



|      |              for of              |                            for in                            |
| :--: | :------------------------------: | :----------------------------------------------------------: |
| 배열 | 인자들을 선서대로 순회할 수 있음 | 인자들을 순회할 수 있으나, <br />순서가 안맞을 수도 있고 다른 메서드가 붙을 수도 있음 |
| 객체 |          인자 접근 불가          |      key에 접근이 가능하나, prototype 속성도 함께 붙음       |



- 디테일한 설명을 뒤로 하고 우선 결론

  - 배열에는 for in을 쓴다.

  - 객체에는 for of를 쓴다. 다만 for in은 key뿐 아니라 prototype key도 가져올 수 있어서 방어코드를 함께 써야 한다. 

    ```
    방어코드 예시1) prototype 키가 있는 경우 제외하고 진짜 key만을 활용하여 사용
    
    for(key in anObject)}
    	if(anObject.hasOwnPropery(key)) {
    		iterator(key);
    	}
    }
    
    방어코드 예시2) 처음부터 keyArray를 사용 
    
    for(key of Object.keys(anObject))}
    	iterator(key);
    }
    ```

## 26. CSS [grid](https://studiomeal.com/archives/533)

1. 속성 개요 

   - flex하고 유사함, 다만 flex가 x축 또는 y축만 다룬다면, grid는 x & y축을 다룸

     **(4줄x4줄 & 3칸x3칸이 기본??)**

   - 그래서 더 복합적이고 디테일한 표현이 가능함



2. 적용요령
   1. 부모태그(grid container)

      - display: grid; 설정

      - grid-template-rows: 행의 갯수, 크기 설정

        ```
        예시) 
        grid-template-rows: 100px 100px 100px 100px;(100px높이의 행 4개 만들기)
        grid-template-rows: 1fr 1fr 1fr 1fr(세로로 4분할 하는 높이가 같은 행 4개 만들기)
        grid-template-rows: repeat(5, 1fr);(같은 높이의 행 5개 만들기)
        grid-template-rows: repeat(3, minmax(100px, auto));(각각 최소 10pxm, 최대 자동 높이의 행 3개 만들기)
        ```

      - grid-template-coulumn: 열의 갯수, 크기 설정(row와 같은요렁)

      - row-gap : 그리드 아이템 간의 간격(가로 간격)

      - column-gap:(세로간에 간격)

      - gap: 가로 세로 함께 표기

        ```
        예시)
        .container {
        	gap: 10px 20px;
        	/* row-gap: 10px; column-gap: 20px; */
        }
        ```

      - justify-content 설정(flex-start / flex-end / center / space-between / space-around/ space-evenly): 좌우정렬조건

      - align-items 설정(<u>stretch</u> / flex-start / flex-end / center) : 수직정렬조건

      2. 자식태그(grid item, 목표태그)에 

         - grid-row: 몇번째 칸에서 시작해서 몇번째 칸까지 쓸건지 
         - gird-colum: 

   3. grid-template-areas(영역 이름으로 그리드 정의)

      각 영역(Grid Area)에 이름을 붙이고, 그 이름을 이용해서 배치하는 방법입니다.
      정말 직관적인 방법이예요.

      ```
      //컨테이너에 전체 구성 넣기
      .container {
      	grid-template-areas:
      		"header header header"
      		"   a    main    b   "
      		"   .     .      .   "
      		"footer footer footer";
      }
      // 각 grid item css 
      
      .header { grid-area: header; }
      .sidebar-a { grid-area: a; }
      .main-content { grid-area: main; }
      .sidebar-b { grid-area: b; }
      .footer { grid-area: footer; }
      
      ```

      

## 27. CSS media query

미디어 쿼리는 CSS3에 포함되어 있으며, 컨텐츠의 변경없이 주로 화면의 크기에 따라 스타일 시트를 달리하여 적절한 모양을 보여줄 수 있[다](https://offbyone.tistory.com/121).



미디어 쿼리 사용법

1. link 요소에 적용

   ```
   <link rel="stylesheet" media="screen and (max-width: 768px)" href="mystyle.css" />
   ```

2. 스타일 시트내에서 **@media** 사용

   ```
   @media screen and (max-width: 768px) { 
   	body { 
   		background-color: lightgreen; 
       } 
   }
   ```

## 28. CSS 가상 셀렉터(hober,active, focus)

1. hover

   **`:hover`** 는 사용자가 포인팅 장치를 사용해 상호작용 중인 요소를 선택합니다. 보통 사용자의 커서(마우스 포인터)가 요소 위에 올라가 있으면 선택됩니다.

```
/* "호버링" 중인 <a> 요소 선택 */
a:hover {
  color: orange;
}
```

2. active

   사용자의 마우스가 해당 요소를 클릭하는 순간부터 떼는 순간까지 요소의 스타일 변경할 수 있습니다.

3. focus

   사용자의 마우스가 해당 요소를 클릭하면 요소의 스타일 변경할 수 있습니다. 



## 29. CSS Transition

"CSS3 애니메이션은 요소에 적용되는 CSS 스타일을 다른 CSS 스타일로 부드럽게 전환시켜 줍니다.

애니메이션은 애니메이션을 나타내는 CSS 스타일과 애니메이션의 중간 상태를 나타내는 키프레임들로 구성되어 집니다.

그리고 애니메이션은 트랜지션보다 훨씬 더 규모가 크고 복잡하며 다양한 능력을 가지고 있기 때문에 좀 더 정밀한 효과를 구현할 수 있습니다."

**애니메이션 장점**

CSS 애니메이션은 기존에 사용되던 자바스크립트를 이용한 애니메이션보다 다음 세 가지 이유에서 이점을 가집니다.

- 자바스크립트를 모르더라도 간단하게 애니메이션을 만들 수 있습니다.
- 자바스크립트를 이용한 애니메이션은 잘 만들어졌더라도 성능이 좋지 못할때가 있습니다. CSS 애니메이션은 frame-skipping 같은 여러 기술을 이용하여 최대한 부드럽게 렌더링됩니다.
- 브라우저는 애니메이션의 성능을 효율적으로 최적화할 수 있습니다. 예를 들어 현재 안보이는 엘리먼트에 대한 애니메이션은 업데이트 주기를 줄여 부하를 최소화할 수 있습니다.



transition VS animation 차이

transition 속성과 animation 속성은 플래시의 기술이나 자바스크립트의 도움 없이 요소에 직접 애니메이션 효과를 적용하는 속성이다.

transition 속성은 요소의 상태가 변해야 애니메이션을 실행한다.

animation 속성은 요소의 모양과 동작을 키프레임 단위로 변경할 수 있다. 키프레임 동작은 재생 횟수, 재생 방향등 여러 애니메이션 속성으로 제어할 수 있다.

transition 속성과 animation 속성의 가장 큰 차이는 transition 속성은 요소의 상태가 바뀌어야 바뀌는 상태를 애니메이션으로 표현하지만, animation 속성은 요소의 상태 변화와 상관 없이 애니메이션을 실행한다. 또한 @keyframes 속성으로 프레임을 추가할 수 있다.





## 30. Object 메서드 

객체 관련 메서드 정리해본다. 

1. Object.entries(해당 객체)

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예)해당객체가 다음과 같을 때,
   const kimObject = {0:"a", 1:"b", 2:"c"}
   console.log(Object.entries(kimObject))
   // [[0,"a"],[1,"b"],[2,"c"]]
   
   응용)
   for(let [a,b] of Object.entries(kimObject)){
   	console.log(`키${a}의밸류는${b}`)
   }
   //
   키0의밸류는a 
   키1의밸류는b
   키2의밸류는c
   ```

   

2. Object.values(해당 객체)

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예
   ```

   

3. Object.keys(해당 객체)

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예
   ```

4. Object.values(해당 객체)

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예
   ```

   

5. Object.assign()

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예
   ```

6. Object.hasOwnProperty

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예
   ```

   

7. Object.create

   -> 해당 객체가 보유한 전체 키&밸류 세트들을 배열로 반환한다. 

   ```
   예
   ```

8. Object.defineProperty()

   대상 객체에서 새로운 동작을 정의한다. 

```
    var viewModel = {};

    (function() {
      function init() {
        Object.defineProperty(viewModel, 'str', {
          // 속성에 접근했을 때의 동작을 정의
          get: function() {
            console.log('접근');
          },
          // 속성에 값을 할당했을 때의 동작을 정의
          set: function(newValue) {
            console.log('할당', newValue);
            render(newValue);
          }
        });
      }
      
      
    //  viewModel이라는 객체에서 str이라는 속성에 'get'과 'set'이라는 기능을 부여한 것.(prototype과 같은것일까?)
    	viewModel.str // get 실행
    	viewModel.str = "" // set 실행
    // view 배우는 과정에서 view의 reactivity를 보여준 예시 
```



## 31. CSS[ Flex](https://studiomeal.com/archives/197)

1. 속성 개요 

   - flex container 내부에, flex item들을 알맞게 짜넣기 위한 기능임 
   - item이 Block요소 일지라도 inline요소화 된다.(즉 width 특정이 가능함)
   - item의 height는 컨테이너 높이에 100%맞출 수 있다.(flex-direction : row, align-items: stretch 시)

2. 적용요령
   1. 부모태그(flex container)

      - display: flex; 또는 inline-flex; 입력 (Block or inline 여부)

      - flex -direction 설정(<u>row</u> / column / row-reverse / column-reverse): item을 쌓는 방향/순서
      - flex-wrap 설정(<u>nowrap</u>/ wrap) : 줄바꿈 속성	</li>
      - justify-content 설정(flex-start / flex-end / center / space-between / space-around/ space-evenly): 좌우정렬조건
      - align-items 설정(<u>stretch</u> / flex-start / flex-end / center) : 수직정렬조건

      2. 자식태그(flex item, 목표태그)에 

         - flex-grow(<u>0</u> / 기타 정수) : 0외의 수를 쓰면 자식태그 width가 stretch 됨, 각 자식태그 grow값에 비례하여 stretch 됨 
         - align-self(<u>auto</u> / stretch / flex-start / flex-end / center): flex items의 개별 조작용



## 32. position

1. static(기본값)

   left, right 속성이 비활성화 됨

2. relative

   상하좌우 속성을 부여할 경우 : 부모태그 및 형제 태그 위치 를 고려하여 위치 조정 가능

3. absolute

   형제태그를 고려하지 않는다. = 형제태그 유무를 가리지 않는다 = 다른 형제태그와 겹침 현상이 일어남

   부모태그의 속성을 상속하지 않는다 = 넓이나 높이를 자기 필요한 만큼만 갖는다.

   상하좌우 속성을 부여할 경우, 

   1. 부모태그 position이 static인 경우 : 부모태그를 무시하고 차상위 부모태그의 위치를 기준으로 절대위치를 갖는다.
   2. 부모태그 position이 static이외의 것인 경우 : 부모태그를 기준으로 절대적 위치를 갖는다. 

4. fixed

   absolute와 유사하지만, 차이점은, 

   1. 부모태그의 postion 상태와 무관하게 절대적 위치를 갖는다. 
   2. 스크롤을 무시한다.

## 33. !important

## 34. BEM

## 35.HTML 태그: i 



"<i> 요소의 텍스트는 보통 이탤릭체로 표현되며, 전문용어나 다른 언어의 관용구, 문어체, 서양 문헌에 나오는 배 이름 등을 나타낼 때 사용됩니다."

"*태그*는 글자를 기울여서 표시하는 *태그*로, italic의 약자입니다."



다만, css를 활용하여 기호를 넣고자 할 때, 내용 없는 태그가 필요하고, 이때 <i>가 즐겨 사용된다. 

이유는 아마도 아래와 같다고 한다. 

1. 아무태그나 써도 된다면 타이핑 길이가 짧은 i가 경제적인 면
2. 본래의 쓰임인 italic 스타일은 font-style에서 구현이 가능하기 때문에 i태그가 잘 쓰이지 않는 다는 점 
3. 마치 icon의 줄임말 같아 상대적으로 어울린다는(?) 점







## 36.Ajax

Ajax([에이젝스])

- 99년 MS가 IE에 탑재시킴 / 04년 Gmail에서 Ajax를 활용한 리로드 없는 메일서비스를 제공함 / 

  이후 Ajax라는 이름이 명명(Asynchronous Javascript And Xml)

- 장점 : 전체 Data를 가져오는게 아니라 필요한 부분의 정보만 통신함(?)

  - url이 변경되지 않음(single page Application??)

- 주요문법

-  type : 'post', // 타입 (get, post, put 등등)

- url : '/test', // 요청할 서버url

- async : true, // 비동기화 여부 (default : true)

- headers : { // Http header
        "Content-Type" : "application/json",
        "X-HTTP-Method-Override" : "POST"
      },

- dataType : 'text', // 데이터 타입 (html, xml, json, text 등등)

- data : JSON.stringify({ // 보낼 데이터 (Object , String, Array)
      }),

- success : function(result) { // 결과 성공 콜백함수
      console.log(result);
  },

- error : function(request, status, error) { // 결과 에러 콜백함수
      console.log(error)
  }

- 

  ```
  const apiCall = () => {
     const res = $.ajax({
         url: 
         headers: 
         method: "POST",
         data:
         dataType: "json",
     }
  ```

  

## 37. CORS

1. 개요

   "Cross-Origin Resource Sharing"(교차출처 리소스 공유)

   "다른 도메인에 접근할수 있는 권한을 부여하도록 브라우저ㅇ가 알려주는 체제입니다."

   "다른 도메인에 통신을 할때 CORS 요청을 실행합니다."

   "보안 상의 이유로, 브라우저는 스크립트에서 시작한 교차 출처 HTTP 요청을 제한합니다."

   "같은 출처에서만 리소스를 공유할 수 있다(SOP). 단, CORS 정책을 지킨 리소스 요청은 허용한다"

2.  CORS의 필요성

   보안에 취약함.

## 38. response 객체



## 39. status 코드 

**http 상태코드** - "HTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 응답은 5개의 그룹으로 나누어집니다: 정보를 제공하는 응답, 성공적인 응답, 리다이렉트, 클라이언트 에러, 그리고 서버 에러."



100번대 : 정보를 제공하는 응답

200번대 : 성공적인 응답

300번대 : 리다이렉트

400번대 : 클라이언트 에러

500번대  : 서버 에러



## 40.Single Page Application

## 41.Pjax

## 42. ECMA

## 43. Babel 

## 44. Jquery DOM Insertion, Inside

1. .append()

   생성기능과 추가 기능을 겸한 기능임

   단, 대상 element가 여러개일 경우, 생성 및 추가가 각각의 대상 element에 모두 복제되어 붙게 됨

   

   문법 : 대상element**.append**(추가될 element) 

   ```
   예시)
   //before
   <h2>Greetings</h2>
   <div class="container">
     <div class="inner">Hello</div>
     <div class="inner">Goodbye</div>
   </div>
   
   //append 사용 : $( ".inner" ).append( "<p>Test</p>" );
   
   //After 
   
   <h2>Greetings</h2>
   <div class="container">
     <div class="inner">
       Hello
       <p>Test</p>
     </div>
     <div class="inner">
       Goodbye
       <p>Test</p>
     </div>
   </div>
   ```



  - 이미 생성된 요소의 이동만도 가능하다(생성없이 이동만)

    ```
    예시) 
    
    //before
    
    <h2>Greetings</h2>
    <div class="container">
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>
    
    //append 사용 : $( ".container" ).append( $( "h2" ) );
    
    //After 
    
    <div class="container">
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
      <h2>Greetings</h2>
    </div>
    
    ```

- 여러개의 인수를 입력해서 복수의 요소를 추가할 수도 있다. 

  예) $( "body" ).append( $newdiv1, [ newdiv2, existingdiv1 ] );





1. .appendTo()

   append와 같은 기능인데, method의 앞뒤 위치 기준이 다르다. 

   append : 목표(부모) element.append(추가될 element)

   appendTo: 추가될Element.appendTo(목표 element) 

   즉, 둘이 같은 기능인데 문법만 다른 상황임. 



1. .html()
   - 대상 요소의 내부 html을 return  // 빈 괄호로 실행할 경우
   - 대상 요소의 innerHTML을 설정 // 괄호에 내용 넣을 경우 
2. .prepend()
   - append와 동일한 기능 
   - 차이점은 추가할 목표 요소에 삽입시킬 디테일한 위치임 
   - prepend >> 목표요소 여는 태그에 다음 순서로 붙음
   - append >> 목표요소 닫는태그 직전 순서로 붙음
3. .prependTo()
   - 생략
4. .text()
   - .html()과 유사 기능, 단 HTML이 아니라 text만이 대상
   - innerHTML과 innerTEXT사이의 차이와 같은 듯

* jquery DOM객체의 태그값을 반환하는 법 : 
  1. get() 함수 이용
  2. [0] 붙이기 

## 45. SVG

SVG(Scalable Vector Graphics)



https://a11y.gitbook.io/graphics-aria/svg-graphics



"스케일러블 벡터 그래픽스(Scalable Vector Graphics, **SVG**)는 2차원 벡터 그래픽을 표현하기 위한 XML 기반의 파일 형식으로, 1999년 W3C(World Wide Web Consortium)의 주도하에 개발된 오픈 표준의 벡터 그래픽 파일 형식이다."



PNG 와 SVG 의 가장 큰 차이점은 이미지를 구성하는 방식이다.

PNG 는 화소(pixel) 단위로 구성되는 형태로써, 비트맵 방식이라고 불린다.

SVG 는 수학을 기반으로 하는 점, 직선, 곡선과 같은 형태로 구성하는 방식이다.



- png, jpeg, gif - 래스터 이미지(Raster Image), 비트맵
- svg - 벡터 이미지(Vector Image), 벡터



툴로 설명하자면, 벡터 방식은 일러스트레이터이고, 비트맵 방식은 포토샵을 예로 들 수 있다.



SVG를 사용하는 이유

SVG를 사용하여 접근성을 높이는 것이 보다 쉬울 뿐만 아니라, 기존 이미지 포멧(예: PNG, JPEG) 보다 파일 크기가 작기 때문에 웹 성능이 크게 향상 될 수 있습니다. 게다가 스크린 크기를 확대해도 선명함을 유지하기에 로고, 아이콘, 인포 그래픽 요소 등에 사용하기 적합합니다.

**확장성(Scalability)**

SVG는 반응성(Responsive)이 좋아 아무리 크기를 키워도 선명함이 유지됩니다. 브라우저 배율을 확대해서 SVG 이미지와 다른 이미지(예: PNG, JPEG) 포멧을 비교해보세요.

SVG는 벡터(Vector) 그래픽 포멧으로 이미지를 확대해도 선명도가 유지됩니다.



관련 태그

1. `svg` 태그 :컨테이너로서 묶음을 의미합니다. 내부에 그래픽을 담기 위한 그릇과 같은 태그입니다.  

   1. `viewPort` 

      svg는 이미지를 나타내는 path,rect,circle등의 집합체로서의 태그이기 때문에,

      svg자체의 width와 height만을 조절해서는 이미지를 변경할 수 없다. 

      svg의 w와h가 나타내는것이 viewPort로서, 이미지 사이즈와는 별개로 화면에 보여지는 영역을 설정하는 개념이 된다. 

      즉 하위 태그 circle이 w=200px, h=200px일 때, svg w=100px, h=100px라면 viewPort가 1/4이 되어 원의 1/4만 보이게 된다. 

   2. `viewBox`속성 
      viewBox는 아래의 4개의 값으로 구성되어있다. 

      > viewBox = "<min-x>, <min-y>, <width>, <height>"

      <min-x>, <min-y>는 svg요소 내에서 viewBox의 좌표를 정의하고 <width>, <height>는 svg요소가 가지는 영역에 맞춰 svg의 요소를 확대할 지, 축소할 지를 정의합니다.
      <min-x>, <min-y>는 왼쪽 최상단을 기준으로 합니다. 여기서 정해진 기준으로 viewbox가 그려지게 됩니다. 

      뷰박스의 width와 hight는 뷰박스가 이미지의 어느범위까지를 포함할 것인가의 내용이 담기게 된다. 하지만 화면에 비추게 될 사이즈는 svg의 width와 height로서, 뷰박스의 사이즈가 이미지의 범위를 나타내고 sbv의 사이즈는 그 범위를 얼마만큼의 크기로 보여줄지를 보여주게 되는 것이다. 

   3. 

      

2. `filter`태그 : SVG 그래픽에 특수 효과를 추가하는 데 사용됩니다.

3. filter관련 태그 : <fe....>태그들
   1. <feBlend> : 이미지 결합용 필터
   2. <feColorMatrix> : 색상 변환을 위한 필터
   3. <feOffset> : 그림자를위한 필터
   4. <feDistantLight>, <fePointLight>, <feSpotLight> : 조명용 필터
   5. 

4. <defs></defs> : `<defs>` 요소는 추후에 사용되는 그래픽 객체를 저장하는 데 사용된다. `<defs>` 요소 내에 생성 된 객체 는 직접 렌더링되지 않습니다. 그것들을 표시하려면 ( 예를 들어 [`` ](https://runebook.dev/ko/docs/svg/element/use)요소를 사용 하여) 참조해야합니다 .

그래픽 객체는 어느 곳에서나 참조 할 수 있지만 `<defs>` 요소 내에 이러한 객체를 정의 하면 SVG 컨텐츠의 이해가 용이 해지며 문서의 전체 액세스 가능성에 도움이됩니다.

2. <path/>태그

   \- <path /> 태그는 일러스트레이터처럼 패스(선과 면)을 이용한 태그입니다.

   \- 속성 중 d라는 속성에 다양한 패스 데이터를 사용할 수 있습니다.

3. <d> 속성

   | **데이터 종류** | **설명**                 |
   | --------------- | ------------------------ |
   | M               | 이동좌표                 |
   | L               | 선길이                   |
   | H               | 수평선                   |
   | V               | 수직선                   |
   | C               | 곡선                     |
   | S               | 부드러운 곡선            |
   | Q               | 2차 베지어 곡선          |
   | T               | 부드러운 2차 베지어 곡선 |
   | A               | 타원형 호                |
   | Z               | 가까운 경로              |

4. <text></text>태그 

   



## 46. Jquery - Event Object



event.currentTarget

event.data

event.delegateTarget

event.isDefaultPrevented()

event.islmmediatePropagationStopped()

event.isPropagationStoppted()

event.metaKey

event.namespace

event.pageX

event.pageY

event.preventDefault()

event.relatedTarget

event.result

event.stopImmediatePropagation()

event.stopPropagation()

event.target

event.timeStamp

event.type

event.which



## 47.dir

## 48. 정규 표현식(Reqular Expression)

참고 링크 https://www.nextree.co.kr/p4327/



**"정규 표현식은 문자열에 나타는 특정 문자 조합과 대응시키기 위해 사용되는 패턴입니다."**

**"정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 [형식 언어](https://ko.wikipedia.org/wiki/형식_언어)이다. "**

**"프로그래밍 언어에서 문자열의 검색과 치환을 위해 지원하고 있다."**

**"정규 표현식은 '검색 엔진', '워드 프로세서'와 '문서 편집기'의 찾아 바꾸기 대화상자, 그리고 'sed', 'AWK'와 같은 '문자 처리 유틸리티', '어휘 분석' 등에 사용된다"**

- 정규 표현식의 원리

  아래 등의 메타문자 등을 통해 패턴을 규정하여 문자 조합을 대응시킴

  - 수량자(quantifier)
  - 선택적인 대안을 가리키는 논리적 OR 문자, 
  - 원자의 존재를 부정하는 NOT 문자
  - 전에 일치된 원자를 참조할 수 있게 하는 역참조(backreference)

  

- 예시

  ```
  gray|grey //  "gray" 나 "grey" 둘다 의미
  gr(a|e)y  //  "gray" 나 "grey" 둘다 의미
  colou?r   //  "color"와 "colour"
  ab*c      //  "ac", "abc", "abbc", "abbbc" 등을 모두 의미 
  ```

- 정규식을 만드는 방법

  1. 리터럴(슬래쉬"/"로 감싸는 패턴)을 사용하는 방법 // var re = /ab+c/;
  2. RegExp 객체의 생성자 함수를 호출하는 방법        // var re = new RegExp("ab+c");

- Flag(3종만 표기함)

  1. g : global, 문자열내의 모든 패턴을 찾는다.
  2. i : ignore, 대소문자는 구분하지 않는다.
  3. m : Multi Line, 문자열의 행이 바뀌어도 찾는다. 

- #### POSIX 기본 및 확장 표준 문법

  | 메타문자 |         기능          | 설명                                                         |
  | :------: | :-------------------: | :----------------------------------------------------------- |
  |    .     |         문자          | 1개의 문자 <br />anyCharacter, white  space 마저도.          |
  |   [ ]    |      문자 클래스      | squer bracket;<br />대괄호안의 문자와 일치하는 경우,<br /> "\|"을 여러개 쓴 것과 같은 의미. 예를 들면 [abc]d는 ad, bd, cd를 뜻한다. 또한, "-" 기호와 함께 쓰면 범위를 지정할 수 있다. <br />[a-z]는 a부터 z까지 중 하나, "[1-9]"는 1부터 9까지 중 하나와 일치하는 경우를 말한다 |
  |    ^     |         처음          | '문자열이나 행의 처음부분의' 를 의미(단 대괄호 내에 쓰인 ^는 다른의미임) |
  |   [^]    |         부정          | 문자 클래스 안의 문자를 제외한 나머지를 선택한다. 예를 들면 [ ^ab]cd는 ad, bd, cd는 포함하지 않고 ed, fd 등을 포함한다. [^a-z]는 알파벳 소문자로 시작하지 않는 모든 문자를 의미한다. |
  |    $     |          끝           | '문자열이나 행의 끝 부분의' 를 의미                          |
  |   ( )    |        하위식         | sub pattern<br />여러 식을 하나로 묶을 수 있다. "abc\|adc"와 "a(b\|d)c"는 같은 의미를 가진다.<br />(ab)a 또는 b에 해당하는  단어 a 또는 b를 찾을 때에는 [ab]도 똑같이 사용할 수 있는데() 사용법의 장점은 여러글자도 대입시킬수 있다는 점이다.(montues)day // monday or tuesday 의미, [] 로는 표현 불가 |
  |    \     |                       | Escape 기능(=문자를 메타문자가 아닌 것으로 인식하게함) //  <br />$ : 달러문자 그 자체                                                                                                                       $ : 메타기호 $(정규표현식 $는  뒷쪽 단어찾기 의미) |
  |    *     |        0회이상        | '0개 이상의 문자' 의미<br /> a*b ; // a가 n개, b 가 한개 결합된 형태를 의미함 // "ab", "aab", "aaab"를 포함한다.<br />a가 0개인 case도 해당되기 때문에 "b"도 포함된다. |
  |    +     |        1회이상        | '1개 이상의 문자' 의미 // 나머지 특성은 *와 동일함           |
  |    ?     | 없거나,     1개인경우 |                                                              |
  |    {}    |          n개          | a{5}; // aaaaa 의미                                          |
  |  {m, n}  |   m회 이상 n회 이하   | "a{1,3}b"는 "ab", "aab", "aaab"를 포함하지만, "b"나 "aaaab"는 포함하지 않는다.<br />m 또는 n을 생략하면 한가지 조건만 반영됨<br />{3:,}; // 3이상 ~ |
  |    \n    |  일치하는 n번째 패턴  | 일치하는 패턴들 중 n번째를 선택하며, 여기에서 n은 1에서 9 중 하나가 올 수 있다 |
  |    \w    |         word          | 단어 인식(알파벳,숫자,_(언더바))로 구성된 단어 확인          |
  |    \W    |         !word         | 단어가 아닌것 인식<br />공백, 기호, 특수문자                 |
  |    \d    |         digit         | 숫자인식(0~9) , [0-9] 와 같은 의미                           |
  |    \D    |        !digit         | 숫자가 아닌것 인식                                           |
  |    \b    |       boundary        | 띄어쓰기 식별                                                |

  

- 사용 예시

  ```
  날짜 형식 지정하여 리턴하는 메서드 구현
  Date.prototype.format = function (f) { //(1)
      if (!this.valueOf()) return " ";
      var weekKorName = ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"];
      var weekKorShortName = ["일", "월", "화", "수", "목", "금", "토"];
      var weekEngName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      var weekEngShortName = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      var d = this;
      return f.replace(/(yyyy|yy|MM|dd|KS|KL|ES|EL|HH|hh|mm|ss|a\/p)/gi, function ($1) {
          switch ($1) { //(2)
              case "yyyy": return d.getFullYear(); // 년 (4자리)
              case "yy": return (d.getFullYear() % 1000).zf(2); // 년 (2자리)
              case "MM": return (d.getMonth() + 1).zf(2); // 월 (2자리)
              case "dd": return d.getDate().zf(2); // 일 (2자리)
              case "KS": return weekKorShortName[d.getDay()]; // 요일 (짧은 한글)
              case "KL": return weekKorName[d.getDay()]; // 요일 (긴 한글)
              case "ES": return weekEngShortName[d.getDay()]; // 요일 (짧은 영어)
              case "EL": return weekEngName[d.getDay()]; // 요일 (긴 영어)
              case "HH": return d.getHours().zf(2); // 시간 (24시간 기준, 2자리)
              case "hh": return ((h = d.getHours() % 12) ? h : 12).zf(2); // 시간 (12시간 기준, 2자리)
              case "mm": return d.getMinutes().zf(2); // 분 (2자리)
              case "ss": return d.getSeconds().zf(2); // 초 (2자리)
              case "a/p": return d.getHours() < 12 ? "AM" : "PM"; // 오전/오후 구분
              default: return $1;
          }
      });
  };
  String.prototype.string = function (len) {
      var s = '', i = 0;
      while (i++ < len) {
          s += this;
      }
      return s;
  };
  String.prototype.zf = function (len) {
      return "0".string(len - this.length) + this;
  };
  Number.prototype.zf = function (len) {
      return this.toString().zf(len);
  };
  ```

  $$
  
  $$

  1. 생성자함수 Date에 프로토타입 메서드 format을 추가

  2. prototype.function format() 해석

     ```
     function format(f){
       return f.replace( 정규표현식 x, function ($1) );
     } // f를 받아 f.replace를 return
     ```

  3. f.replace()해석 

     ```
     f.replace(/(yyyy|yy|MM|dd|KS|KL|ES|EL|HH|hh|mm|ss|a\/p)/gi, function ($1))
      - 함수 replace(a,b)는 첫번째 인자를 찾아 두번째 인자로 교체하는 것
      - 1번 인자 /(yyyy|yy|MM|dd|KS|KL|ES|EL|HH|hh|mm|ss|a\/p)/gi  는 정규표현식에 해당
      - 2번 인자는 익명함수 반환값
     ```

     3-1. 정규표현식 /(yyyy|yy|MM|dd|KS|KL|ES|EL|HH|hh|mm|ss|a\/p)/gi 해석

     ```
     yyyy|yy|MM|dd|KS|KL|ES|EL|HH|hh|mm|ss| 
     --> 
     ```

- lazy quantifer, greedy quantifire

- 주요 메서드 

  1. 정규표현식 메서드

  - RegExp.exec() : 추출하는데 쓰인다. (return type Object)

    ```
    예) 정규표현식 pattern = /a/; // "a"의미
    pattern.exec("abc") = "a" ;
    ```

  - RegExp.test() : 보유 여부 판별(return type Boolean)

    

  2. string 메서드
     - match : 일치부분을 반환함, return type Array // string.match(regex)
     - replace : string.replace(a,b)_a를 b로 치환함

## 49.box-sizing속성

## 50.px vw 등 단위별 특징 비교

단위는 크게 아래와 같이 나눌 수 있다. 

1. 절대 단위

2. 상대 단위 

   

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

## 51.firebase



API Key : AIzaSyA-zauPvHD9Kihy8W_MYjWPLdm-4zG5Fc0



## 52. 구글클라우드 플랫폼



API Key : AIzaSyAJY6L9E7Z8XQk89VxMRkcem1Q0M7Z1CrM

## 53. XMLHttpRequest



통신을 위한 JS API 로서 AJAX의 기초가 되는 메서드이다. 

서버와 상호작용하기 위한 '객체'이며, 전체 페이지의 새로고침 없이 URL로부터 데이터를 받을 수 있음. 

이름에 XML로 되어 있는 것과 통신할 수 있는 데이터의 종류는 무관함. 모든 종류의 데이터를 사용 가능

- 생성자 : XMLHttpRequest()

  ```
  const request = new XMLHttpRequest(); 
  - 통신 시작 전에 객체 생성을 해야만 하기 때문에 위와 같이 객체를 생성한 후에 아래 메서드 사용가능
  ```

- 메서드

  XMLHttpRequest.open : HTTP요청에 대한 속성을 지정합니다.

  ```
  const request = new XMLHttpRequest();
  request.open("method", "url", "async", "username","password")
  ```

  XMLHttpRequest.send(content) : open에 지정된 속성을 이용하여 HTTP 요청을 전송

- 속성

  XMLHttpRequest.responseText : 요청에 대한 응답을 텍스트로 반환

  XMLHttpRequest.status : HTTP 상태코드 숫자로 반환

  XMLHttpRequest.statusText : 상태코드에 대한 문자열 반환

  

  

## 54. animate

- 애니메이션 효과 제공(Jquery에만 있음)

- 문법 : 

  .animate(property [, duration] [, easing] [, complete] )

  - property : 
  - duration : 애니메이션 속도(ms), 정확히는 완료되는데 부여할 시간(길어질수록 느리게)
  - easing : swing과 linear 2개의 속성 중 택일, swing이 default.
    - swing : 시작 / 끝에서는 느리게 움직이지만 중간에서는 빨라진다.
    - linear : 일정한 속도로 움직인다.
  - complete : 요소가 사라진 후 수행할 작업

- property : 

  backgroundPositionX / backgroundPositionY / borderBottomWidth / borderLeftWidth / borderRightWidth / borderSpacing / borderTopWidth / borderWidth / bottom / fontSize / height / left / letterSpacing / lineHeight / margin / marginBottom / marginLeft / marginRight / marginTop / maxHeight / maxWidth / minHeight / minWidth / opacity / outlineWidth / padding paddingBottom / paddingLeft / paddingRight / paddingTop / right / textIndent / top / width / wordSpacing

  

- 예시

  ```
  $("#three").click(() =>{
    $("#kimin").animate({
      'height': '11px'
    }, 2000);
  });
  ```

- 가능한 기능 : 클릭으로 메뉴 길어지게 하기(width), 이동시키기(margin-), 스크롤내림에 따라 이미지 들어오기



## 55. CSS:transition

"속성을 천천히 변화시키는 속성"

- 문법 : transition: property timing-function duration delay | initial | inherit
  - **property :** transition을 적용시킬 속성을 정합니다. 
  - **timing-function :** transition의 진행 속도를 정합니다. 
  - **duration :** transition의 총 시간을 정합니다. 
  - **delay :** transition의 시작을 연기합니다. 
  - **initial :** 기본값으로 설정합니다.
  - **inherit :** 부모 요소의 속성값을 상속받습니다.

-  예시

  ```
  .divTR{
    transition: height linear 10ms;
    background-color: white;
    vertical-align: middle;
  }
  ```

  



## 56.fileReader 객체



'**FileReader** 객체는 웹 애플리케이션이 비동기적으로 데이터를 읽기 위하여 읽을 파일을 가리키는 File 혹은 Blob 객체를 이용해 파일의 내용을(혹은 raw data버퍼로) 읽고 사용자의 컴퓨터에 저장하는 것을 가능하게 해 줍니다.'

"File 객체는 <input> 태그를 이용하여 유저가 선택한 파일들의 결과로 반환된 FileList 객체, 드래그 앤 드롭으로 반환된 DataTransfer 객체 혹은 HTMLCanvasElement의 mozGetAsFile() API로 부터 얻습니다."

```
<input type="file" id="my_file_input">

$("#my_file_input").on("change", function(e){
    var files = e.target.files; //input file 객체를 가져온다.
    for (let i = 0; i != files.length; ++i) {
        let f = files[i];
        var reader = new FileReader(); //FileReader를 생성한다.              
        //성공적으로 읽기 동작이 완료된 경우 실행되는 이벤트 핸들러를 설정한다.
        reader.onload = function(e) {
           ...엑셀파일을 읽어서 처리하는 로직...
        }; 
        reader.readAsBinaryString(f);//파일객체를 읽는다. 완료되면 원시 이진 데이터가 문자열로 포함됨.
    }	
});
```

- 기능 : 

  fileReader 객체의 핵심 key & value 는 result 값이다. 

  file의 result를 해석함으로서 file을 활용할 여러가지 방향으로 넘어가는 것으로 보인다. 

  다만, result는 일종의 type을 지정하여 해석 할 수 있는데, 각각 아래와 같으며, 특정 type으로 지정하여 읽고하면 result를 return하기 전, 메서드를 통해  readAs를 지정해야 한다. 

  - result type
    1. DataURL: 데이터 URL로 만드는 방법, base64등
    2. BinaryString: 이진데이터 반환 서버 같은 곳에서 읽기에 용이함
    3. ArrayBuffer: 객체를 반환함. 데이터를 일정한 크기로 조금씩 서버로 보낼 수 있음.서버로 보낼때 사용
    4. Text: txt파일 읽을 때 사용

- 메서드

  - fileReader.onload: `load` 이벤트의 핸들러. 이 이벤트는 읽기 동작이 성공적으로 완료 되었을 때마다 발생합니다. // 업로드 이후 작업을 비동기적으로 처리하기 위해 필요.

  - fileReader.readAsDataURL(파일) : 지정된 데이터의 내용 읽기를 시작합니다. [`Blob`](https://developer.mozilla.org/ko/docs/Web/API/Blob)완료되면 `result`속성 `data:`에 파일 데이터를 나타내는 URL이 포함 됩니다.

  - fileReader.readAsBinaryString(파일) : 지정된 데이터의 내용 읽기를 시작합니다. [`Blob`](https://developer.mozilla.org/ko/docs/Web/API/Blob)완료되면 `result`속성 `data:`에 파일 데이터를 나타내는 URL이 포함 됩니다.

  - fileReader.readAsArrayBuffer(파일) : 지정된 데이터의 내용 읽기를 시작합니다. [`Blob`](https://developer.mozilla.org/ko/docs/Web/API/Blob)완료되면 `result`속성 `data:`에 파일 데이터를 나타내는 URL이 포함 됩니다.

  - fileReader.readAsText(파일) : 지정된 데이터의 내용 읽기를 시작합니다. [`Blob`](https://developer.mozilla.org/ko/docs/Web/API/Blob)완료되면 `result`속성 `data:`에 파일 데이터를 나타내는 URL이 포함 됩니다.

  - fileReader.result : 파일의 컨텐츠

    ** (1)읽기 작업이 완료되고(onload) , (2)데이터의 포맷이 정해진 후(readAs~실행 후) 유효



## 57. sort()



sort는 배열의 인자들을 소팅하여 배열을 다시 return함.

문법 : 대상배열.sort([compareFunction])

이 때, compare function은 선택사항이며, 선택하지 않을 경우, '유니코드 코드포인트 값 순'을 따른다. (아스키코드??)

```
**유니코드 코드포인트라는게 무엇인지 몰랐는데, 텍스트와 숫자 등에는 모두 일정한 코드포인트를 가지고 있는 듯 하다.
특히, console에  "가">"나" 를 찍게되면 false가 return되는데, 이는 stirng "가"와"나"에 유니코드 코드포인트가 부여되어 있고,이 때문에 비교연산자를 취할 수 있으며 "가"의 유니코드 코드포인트가 "나"의 유니코드 코드포인트보다 작음을 비교 할 수 있게 한다.
```

compare function이 필요할 경우에는 아래와 같은 문법을 취한다. 

```
const compareFunction = (a,b) =>{
	return number
}
```

기본 형태는 위 함수와 같이 숫자를 return 하는 형태이면 되고, 원리는 마치 reduce 함수처럼, 배열의 인자를 연쇄적으로 2개씩 꺼내 비교하고, return값에 따라 아래와 같이 순서를 변경하는 듯 하다. (내 추론)

0인 경우 = 정렬하지 않음

+인 경우 = 순서변경

-인 경우 = 기존순서유지 

그래서, a와b간의 관계를 통해 원하는 compareFunction이 적용 가능하다.

```
[1,4,3,2].sort((a,b) => {return b-a}) 의 경우,

a	b	b-a	 배열순서	  비고
-	-	-	[1,4,3,2]	최초
1	4	3	[4,1,3,2]	순서변경
1	3	2	[4,3,1,2]	순서변경
1	2	1	[4,3,2,1]	순서변경
4	3	-1	[4,3,2,1]	순서유지
4	2	-2	[4,3,2,1]	순서유지
3	2	-1	[4,3,2,1]	순서유지

return [4,3,2,1]
```

**기타 예시

```
var items = [
  { name: 'Edward', value: 21 },
  { name: 'Sharpe', value: 37 },
  { name: 'And', value: 45 },
  { name: 'The', value: -12 },
  { name: 'Magnetic', value: 13 },
  { name: 'Zeros', value: 37 }
];

// value 기준으로 정렬
items.sort(function (a, b) {
  if (a.value > b.value) {
    return 1;
  }
  if (a.value < b.value) {
    return -1;
  }
  // a must be equal to b
  return 0;
});

// name 기준으로 정렬
items.sort(function(a, b) {
  var nameA = a.name.toUpperCase(); // ignore upper and lowercase
  var nameB = b.name.toUpperCase(); // ignore upper and lowercase
  if (nameA < nameB) {
    return -1;
  }
  if (nameA > nameB) {
    return 1;
  }

  // 이름이 같을 경우
  return 0;
});
```





## 58. HTML 태그 label



"`label`태그는 `input`태그의 의미를 정의하기 위한 태그입니다."

"주요 속성은 for입니다."

- label의 for의 값과 양식의 id의 값이 같으면 연결됩니다.

- label을 클릭하면, 연결된 양식에 입력할 수 있도록 하거나 체크를 하거나 체크를 해제합니다.
- input 등 양식을 label로 감싸면, id와 for가 없이도 같은 결과를 얻을 수 있습니다.
- 이러한 <label> 요소는 브라우저에 의해 일반적인 텍스트로 랜더링되지만, 사용자가 마우스로 해당 텍스트를 클릭할 경우 <label> 요소와 연결된 요소를 곧바로 선택할 수 있어 사용자의 편의성을 높일 수 있습니다.

<label> 요소를 사용할 수 있는 요소는 다음과 같습니다.

\- <button>, <input>, <meter>, <output>, <progress>, <select>, <textarea>

## 59. CSS: css로만 도형그리기(Pure CSS Drawing)



https://nuli.navercorp.com/community/article/1132695

CSS를 적극적으로 활용하면 이미지 파일을 사용하지 않아도 CSS 만으로도 그림을 그릴 수 있음,

CSS3가 새롭게 등장하면서 border-radius, CSS gradient, box-shadow, CSS transform 과 같이 그리기에 활용 할 수 있는 속성들이 많아져 곡면과 그래디언트, 그림자등을 표현하기가 수월해 지면서 CSS 만으로 그림을 그리는 다양한 시도들이 활발해지기 시작했습니다.



- 원리

  1. 사각형 : 빈 태그에  width와 height로 사이즈를 규정하고 background 컬러를 넣어 만듬

  2. 원 : 사각형과 동일한 원리 + border-radius: 50% 부여

  3. 삼각형 : border의 속성을 이용하게 됨, 4방향의 border 각 스타일을 지정함에 있어서, 

     각 모서리의 겹침 부분은 대각선 모양으로 영역이 나뉘게 된다. 

  ![image-20211102110606758](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20211102110606758.png)

  ​	이 때, width:0px height: 0을 적용하게 되면 모서리만 남게 되고, 

![image-20211102110949632](C:\Users\tt\AppData\Roaming\Typora\typora-user-images\image-20211102110949632.png)

​		이렇게 되는 것이다. 이때 사용하고자 하는 삼각형을 부위를 제외한 border를 transperent 시키면 삼각형만 남는 원리.

4. 마름모: 삼각형 2개를 이어붙이는 원리, 단 태그를 2개쓰기보다 절반을 만든후 가상선택자 ::after를 이용해 한태그에 2개의 도형을 덧붙이면 됨 
5. 육각형 별 : 삼각형과 역삼각형을 합친 형태, 역시 태그를 2개 만들지 말고 1개는 가상선택자로 만들면 됨 

## 60.CSS: 가상  엘리먼트 :after : before



## 61.CSS: css 접두어

https://dolly77.tistory.com/9

▼ CSS 속성 중에 접두어를 붙어야 되는 경우가 있습니다. 각 접두어의 의미를 알아 보겠습니다. 쓰는 방법은 속성 앞에 붙이면 됩니다.

 

-webkit- : 구글, 사파리 브라우저에 적용

-moz- : 파이어폭스 브라우저에 적용

-ms- : 익스플로러에 적용, 보통 생략합니다.

-o- : 오페라 브라우저에 적용



## 62.  태그: xmlns



### <XML Namespace>

XML에서는 태그의 이름을 개발자가 정의하기 때문에, 같은 이름의 요소(element)가 생길 수 있다. 따라서 충돌을 막기위해서 Namespace를 사용한다.



**XML은 무엇인가**

- eXtensible Markup Language의 약자입니다.
- HTML과 비슷한 마크 업 언어입니다.
- 데이터를 저장하고 전송하기위해 설계되었습니다.
- 자기-설명적(self-descriptive)입니다.
- W3C의 권장 사항입니다.



"xml문서상에서는 유효하지만 HTML 문서상에서는 유효하지 않음"





## 63.SCSS



"SCSS와 SASS는 **CSS를 편리하게 이용할 수 있도록 도와주며 추가 기능도 있는 확장판 ( CSS를 확장하는 스크립팅언어 )**이다."



**사용 이유**

\1. CSS는 작업이 크고 고도화 될수록 불편함이 생긴다.

\- 불필요한 선택자(Selector)많아짐

\- 연산 기능의 한계

\- 구문의 부재



\2. SCSS와 SASS는 작업을 쉽게 해준다.

\- 가독성과 재사용성을 높여주어 유지보수가 쉬워지게 도와준다.

\- CSS보다 심플한 표기법으로 CSS를 구조화하여 표현할 수 있다.

\- 스킬 레벨이 다른 팀원들과의 작업 시 발생할 수 있는 구문의 수준 차이를 평준화할 수 있다.



+@ SASS는 CSS의 태생적 한계를 보완하기 위해 아래와 같은 추가기능과 유용한 도구들을 제공한다.

\- 변수의 사용

\- 조건문과 반복문

\- Import

\- Nesting(중첩구조) : 들여쓰기 & 활용

\- Mixin :@mixin 어노테션을 붙여 함수를 만들고 @include로 가져다 쓸 수 있음

\- Extend/Inheritance





**SASS와 SCSS의 차이**

SASS = Syntactically Awesome Style Sheets = 문법적으로 멋진 스타일 시트..

SCSS = Sassy CSS = 멋진 CSS

Sass외에 다른 전처리기들도 물론 존재하고, 후처리기의 개념도 있다.

- LESS
- Stylus
- cssnext
- PostCSS



SCSS, Sass를 사용하기 위해서는 별도의 loader가 필요하다.

그리고 앞서 말한 CSS의 단점을 보완하기 위한 확장된 기능들의 간단한 예시/가이드를 아래 공홈링크에서 참고 가능하다.

공홈 가이드 : https://sass-lang.com/guide



## 64.위도와 경도로 두 지점간의 거리구하기



구글에 쳐보면 좌표 2개만 변수로 넣으면 거리를 구하는 함수를 안내해주고 있는데, 어떻게 작동하는 것인지는 이해가 안가서 풀어서 적어보려고 한다. 

해당 함수 :

```
function getDistanceFromLatLonInKm(lat1, lng1, lat2,lng2) { //(1)
    function deg2rad(deg) {  //(2)
        console.log(deg)
        return deg * (Math.PI/180);
    }
    var R = 6371; // Radius(반지름) of the earth in km
    var dLat = deg2rad(lat2-lat1); // deg2rad below
    var dLon = deg2rad(lng2-lng1);
    var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);   // (3)
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d = R * c; // Distance in km return d;
    console.log(d)
    return d;
}
```

풀어서 이해해보기 

(1) 두 지점의 위도&경도를 변수로 받게됨 (위도:latitude(-90 ~ 90, 0º는 적도, 90º가 북극) / 경도:longitude(-180 ~ 180) )

(2) degree를 radian으로 바꾸는 함수를 정의 

​	// degree * π / 180 = radian // (각도를 표현하는방법중, (1) 각도법=dgree, (2) 호도법=radian에 해당

(3)

​	// dLat : 위도 거리(Distance of Latitude?), 

​	//dLon : 경도 거리 

​	// 두 점사이의 거리를 삼각형의 대각선이라고 생각했을때, 위도거리는 밑변의 길이/경도거리는 높이의 길이라고 생각하면 될듯

​    // 그렇다면 두 점간의 거리(대각선은) 대략 (dLat^2+dLon^2 )^(1/2) 인것인지??? 

​	// 그렇지만 상기 함수에서는 대각선의 길이를 삼각함수로 구한것으로 보임(삼각함수는 굳이 찾아 이해하지 않고 넘기겠음)

(4) 이하 내용에서 모르는 함수 확인

1. Math.PI : π 
2. Math.sin : 삼각함수의 sine(대각선 / 높이)
3. Math.cos : 삼각함수의 coSine(밑변 / 대각선)
4. Math.atan : 삼각함수의 tangent()
5. Math.sqrt : 제곱근







## 65.CSS: vertical-align

- vertical-align이 간단할것 같은데 매번 잘 안돼서 정리 
- 관련속성
  - middle : 중앙임
  - baseline: (알파벳 표기시의) baseline
  - sub: 바닥
  - super: 위
- 에러 케이스 
  - div에 middle align을 시키기 위해서는 아래 조건이 필요하다.
    1. vertical-align: middle 적용(제일 기본)
    2. display: table-cell; 적용 
    3. float 속성 부여 x 
- 유사 효과
  - div display: flex를 이용하기
    1. div display: flex; 설정
    2. align-items: center; 설정
    3. 단 이 경우엔 내부 중앙정렬 또한 text-align 적용불가. justify-content: sapce around 사용필요

## 66.

## 67.sheetJS

웹에서 테이블을 편하게 다루기 위해, 엑셀처럼 조작되는 테이블에 관해 알아보게 되었다. 

필터링,정렬, 수식, 표단위 붙여넣기, 엑셀 import&export를 사용하기를 바랬는데, sheetJS라는 library가 괜찮은 것 같아 공부해서 활용하고자 한다. 

1. dropsheet.js

```
var DropSheet = function DropSheet(opts) {
  if(!opts) opts = {};
  var nullfunc = function(){};
  if(!opts.errors) opts.errors = {};
  if(!opts.errors.badfile) opts.errors.badfile = nullfunc;
  if(!opts.errors.pending) opts.errors.pending = nullfunc;
  if(!opts.errors.failed) opts.errors.failed = nullfunc;
  if(!opts.errors.large) opts.errors.large = nullfunc;
  if(!opts.on) opts.on = {};
  if(!opts.on.workstart) opts.on.workstart = nullfunc;
  if(!opts.on.workend) opts.on.workend = nullfunc;
  if(!opts.on.sheet) opts.on.sheet = nullfunc;
  if(!opts.on.wb) opts.on.wb = nullfunc;

  var rABS = typeof FileReader !== 'undefined' && FileReader.prototype && FileReader.prototype.readAsBinaryString;
  var useworker = typeof Worker !== 'undefined';
  var pending = false;
  function fixdata(data) {
    var o = "", l = 0, w = 10240;
    for(; l<data.byteLength/w; ++l)
      o+=String.fromCharCode.apply(null,new Uint8Array(data.slice(l*w,l*w+w)));
    o+=String.fromCharCode.apply(null, new Uint8Array(data.slice(o.length)));
    return o;
  }

  function  b(data, cb, readtype) {
    pending = true;
    opts.on.workstart();
    var scripts = document.getElementsByTagName('script');
    var dropsheetPath;
    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i].src.indexOf('dropsheet') != -1) {
        dropsheetPath = scripts[i].src.split('dropsheet.js')[0];
      }
    }
    var worker = new Worker(dropsheetPath + 'sheetjsw.js');
    worker.onmessage = function(e) {
      switch(e.data.t) {
        case 'ready': break;
        case 'e': pending = false; console.error(e.data.d); break;
        case 'xlsx':
          pending = false;
          opts.on.workend();
          console.log(JSON.parse(e.data.d))
          cb(JSON.parse(e.data.d)); break;
      }
    };
    worker.postMessage({d:data,b:readtype,t:'xlsx'});
  }

  var last_wb;

  function to_json(workbook) {
    if(useworker && workbook.SSF) XLSX.SSF.load_table(workbook.SSF);
    var result = {};
    workbook.SheetNames.forEach(function(sheetName) {
      var roa = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {raw:false, header:1});
      if(roa.length > 0) result[sheetName] = roa;
    });
    return result;
  }

  function choose_sheet(sheetidx) { process_wb(last_wb, sheetidx); }

  function process_wb(wb, sheetidx) {
    last_wb = wb;
    opts.on.wb(wb, sheetidx);
    var sheet = wb.SheetNames[sheetidx||0];
    var json = to_json(wb)[sheet];
    opts.on.sheet(json, wb.SheetNames, choose_sheet);
  }

  function handleDrop(e) {
    e.stopPropagation();
    e.preventDefault();
    if(pending) return opts.errors.pending();
    var files = e.dataTransfer.files;
    var i,f;
    for (i = 0, f = files[i]; i != files.length; ++i) {
      var reader = new FileReader();
      var name = f.name;
      reader.onload = function(e) {
        var data = e.target.result;
        var wb, arr;
        var readtype = {type: rABS ? 'binary' : 'base64' };
        if(!rABS) {
          arr = fixdata(data);
          data = btoa(arr);
        }
        function doit() {
          try {
            if(useworker) { sheetjsw(data, process_wb, readtype); return; }
            wb = XLSX.read(data, readtype);
            process_wb(wb);
          } catch(e) { console.log(e); opts.errors.failed(e); }
        }

        if(e.target.result.length > 1e6) opts.errors.large(e.target.result.length, function(e) { if(e) doit(); });
        else { doit(); }
      };
      if(rABS) reader.readAsBinaryString(f);
      else reader.readAsArrayBuffer(f);
    }
  }

  function handleDragover(e) {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  }

  if(opts.drop.addEventListener) {
    opts.drop.addEventListener('dragenter', handleDragover, false);
    opts.drop.addEventListener('dragover', handleDragover, false);
    opts.drop.addEventListener('drop', handleDrop, false);
  }

  function handleFile(e) {
    if(pending) return opts.errors.pending();
    debugger;
    var files = e.target.files;
    var i,f;
    for (i = 0, f = files[i]; i != files.length; ++i) {
      var reader = new FileReader();
      var name = f.name;
      reader.onload = function(e) {
        var data = e.target.result;
        var wb, arr;
        var readtype = {type: rABS ? 'binary' : 'base64' };
        if(!rABS) {
          arr = fixdata(data);
          data = btoa(arr);
        }
        function doit() {
          try {
            if(useworker) { sheetjsw(data, process_wb, readtype); return; }
            wb = XLSX.read(data, readtype);
            process_wb(wb);
          } catch(e) { console.log(e); opts.errors.failed(e); }
        }

        if(e.target.result.length > 1e6) opts.errors.large(e.target.result.length, function(e) { if(e) doit(); });
        else { doit(); }
      };
      if(rABS) reader.readAsBinaryString(f);
      else reader.readAsArrayBuffer(f);
    }
  }

  if(opts.file && opts.file.addEventListener) opts.file.addEventListener('change', handleFile, false);
};

```







## 68.CSS: animation, @keyframes

**1. Animation**

animation 속성은 애니메이션에 이름을 지정하거나 지속시간, 속도 조절 등을 지정할 수 있는 속성을 가지고 있습니다.아래는 애니메이션 속성의 종류입니다.

- animation-name : @keyframes 이름
- animation-duratuion : 타임 프레임의 길이, 키프레임이 동작하는 시간을 설정할 때 사용
- animation-timing-function : 애니메이션 속도 조절 / 그래프 ( linear / ease 등)
- animation-delay : 애니메이션을 시작하기 전 지연시간 설정
- animation-iteration-count : 반복 횟수 지정
- animation-direction : 반복 방향 설정 ( 정방향 / 역방향 / 번갈아가며)
- animation-fill-mode : 애니메이션 시작 / 끝 상태 제어 ( none / forwords / backwords / both )

**1.@keyframes**

@keyframes 는 CSS 애니메이션에서 구간을 정하고 각 구간별로 어떤 스타일을 적용시킬지 정하는 문법입니다.

@keyframes 를 사용하기 위해선 세 가지가 필요합니다.

- animation-name : 사용자가 직접 지정한 이름, @keyframes 가 적용될 애니메이션의 이름
- 스테이지 : from - to 로 0~100% 의 구간
- CSS 스타일 : 각 스테이지(구간)에 적용시킬 스타일







## 69.CSS: transform 

요소에 이동(translate), 회전(rotate), 확대축소(scale), 비틀기(skew) 효과를 부여하기 위한 함수를 제공한다.

단 애니메이션 효과를 제공하지는 않기 때문에 정의된 프로퍼티가 바로 적용되어 화면에 표시된다. 

트랜스폼은 애니메이션 효과를 위해 사용하여야 하는 것은 아니지만 애니메이션 효과를 부여할 필요가 있다면 트랜지션이나 애니메이션과 함께 사용한다.



| transform function    | 설명                                                         |     단위      |
| :-------------------- | :----------------------------------------------------------- | :-----------: |
| translate(x,y)        | 요소의 위치를 X축으로 x만큼, Y축으로 y만큼 이동시킨다.       | px, %, em 등  |
| translateX(n)         | 요소의 위치를 X축으로 x만큼 이동시킨다.                      | px, %, em 등  |
| translateY(n)         | 요소의 위치를 Y축으로 y만큼 이동시킨다.                      | px, %, em 등  |
| scale(x,y)            | 요소의 크기를 X축으로 x배, Y축으로 y배 확대 또는 축소 시킨다. |   0과 양수    |
| scaleX(n)             | 요소의 크기를 X축으로 x배 확대 또는 축소 시킨다.             |   0과 양수    |
| scaleY(n)             | 요소의 크기를 Y축으로 y배 확대 또는 축소 시킨다.             |   0과 양수    |
| skew(x-angle,y-angle) | 요소를 X축으로 x 각도만큼, Y축으로 y 각도만큼 기울인다.      | +/- 각도(deg) |
| skewX(x-angle)        | 요소를 X축으로 x 각도만큼 기울인다.                          | +/- 각도(deg) |
| skewY(y-angle)        | 요소를 Y축으로 y 각도만큼 기울인다.                          | +/- 각도(deg) |
| rotate(angle)         | 요소를 angle만큼 회전시킨다.                                 | +/- 각도(deg) |



## 70.CSS: rotate









## 71. JS: 좌표 값 찾기

- 관련 api
  - getBoundingClientRect() 
  - offsetTop

- offset API

  ```
  $().offset() // {top: x, left:y} return; 
  ```

  



1. 상대위치 구하기

   1-1. Viewport 기준

   ```
   1. 자바스크립트	(api: getBoundigClientRect)
   
   const target = document.getElementById('target'); // 요소의 id 값이 target이라 가정
   const clientRect = target.getBoundingClientRect(); // DomRect 구하기 (각종 좌표값이 들어있는 객체)
   const relativeTop = clientRect.top; // Viewport의 시작지점을 기준으로한 상대좌표 Y 값.
   
   ```

   1-2. 부모요소 기준

​		1-2-1. 부모요소의 position이 relative인 경우,

​					offset API 사용

​		1-2-2. 부모요소의 position이  absolute인 경우,



## 72. 날씨 어플 만들기

1. 
2. 

## 73. todo 매니저 만들기

1. 드래그 드롭

## 74. Vue.js



"vue는 컴포넌트기반으로 SPA를 구축하게해주는 프레임워크"

"MVVM 패턴의 뷰모델 레이어에 해다아는 화면(View)단의 라이브러리이다. "



- vue 특징

  - MVVM패턴

    1. DOM > coreJavascript 방향 

       DOM(HTML, 사용자의 view, 화면) 에서, vue는 eventListener로서의 역할을 하게 된다.

       받은 이벤트는 javascript로 보내주게 된다.

    2. coreJavascript  > DOM 방향 

       자바스크립트에서 data가 변경된 내용은, vue가 data Bindings를 통해서 DOM으로 전달하게 된다.

  - Reactivity 특성

    기존 자바스크립트는 정의하고, 적용하고 2단계로 구성

    vue는 함수화(?)되어 있어서 변수는 연결되어 있고, 변수의 정의 == 변수의 반영으로 되어있음

  

- vue instance

  new Vue({

    el:  " #app"   // #app 요소에 vue instance를 붙인다는 의미이고, 이로 인해  Vue instance에서 지정된 data, methods 등이 #app이하에서도 적용이 된다는 것.

  }) // 하나의 vue instance는 하나의 root component로 생성이 된다.

- 컴포넌트 : 메뉴, 로고, 모달창 등의 UI요소를 재사용 가능하도록 구조화한 것 // 재사용성++ 

  컴포넌트 등록 문법: 

  ```
  1. 컴포넌트 우선 등록 시
  Vue.component('app-header', {
        template: '<h1>Header</h1>'
  });  
  
  2. vue instance에 변수로 넣어서 만들 시
  
  new Vue({
  	el: #app,
  	components:{
  		'이름': {
  			teplate : ``
  		}
  	}
  })
  
  ```

  

SPA : 필요한 영역만 로딩되는 형태, 빠른 페이지 변환, 적은 트래픽 양이라는 장점

CLI : 프로젝트를 빠르게 시작할 수 있도록 폴더구조, 필요한 라이브러리 자동 설치해주는 틀(Command LIne...)

router : 뷰에서 라우팅 기능을 할수 있게한 공식 library 모듈(라우팅이란 웹페이지간의 이동하는 방법)

​			 뷰 라우터는 SPA를 실행할 수 있도록 필요한 부분만 갱신하도록 해준다.

index.js: 폴더마다 만들고, 폴더내에 존재하는 것들과 외부 폴더와의 연결을위해 import export를 모아서 정리해준다. 

App.vue : 최종적으로 브라우저에 나가는 html 틀이라고 볼 수 있음 다만 각 컴포넌트는 보이지 않고, <div id='App'> 태그가 다른 컴포넌트를 흡수함

main.js : 다른 컴포넌트를 App.vue에 'mount'하도록 하는 js파일



```
뷰 cli 설치           : npm install -g @vue/cli
새 프로젝트 시작 & 세팅 : vue create [폴더명] & (default 선택) & 설치
서버 오픈             : npm run serve
라우터 설치 			  : npm install vue-router --save
layout 폴더 & Header.vue 생성
Header디자인을 위해 부트스트랩뷰에서 설치 : npm install bootstrap-vue bootstrap // node_modules에 설치됨
사용을 위해 main.js에 추가 : import .....
```



- templete literal : ${}와 비슷하게 변수는 {{}}에 담는다._console.log()수준의 ㅇㅇ..

- 변수선언, 함수선언 하는 법

  ```
  {{변수명}}
  
  <script>
  	data() {
  		return {
  			변수명 : "변수값",
              변수명 : "변수값"
  		};
  	}
  	methods: {
  		함수명(){
  			
  		}
  	}
  </script>
  ```
  
  - data binding은 나중에 변경시켜야 할 가변적인 데이터를 관리하기에 hardCoding보다 유리하다.
  - data binding 문법은 자바스크립트에 비해 데이터의 변경과정이 간단하기에.. 유용하다. (자바스크립트는 innerText() 등의 함수가 필요하지만, vue는 데이터 갱신이 default)
  - 변경될일이 없다면, hardCoding.
  
- refs

- 라이프사이클 이해가 중요(향후) : 약간 onload같은 느낌

- vue 속성(옵션?, api?)

  | 속성      | 설명                                                         |
  | --------- | ------------------------------------------------------------ |
  | el        | 인스턴스가 그려지는 화면의 시작점 (특정 HTML 태그)           |
  | template  | 화면에 표시할 요소 (HTML, CSS 등)                            |
  | data      | 뷰의 반응성(Reactivity)이 반영된 데이터 속성                 |
  | props     | 외부에서 변수를 받는 거임.                                   |
  | methods   | 화면의 동작과 이벤트 로직을 제어하는 메서드                  |
  | name      | 컴포넌트를 export할 때 component name을 정의                 |
  | component |                                                              |
  | computed  | data에 연계돼서 특정관계성에 의해 조작돼야할 또 다른 data가 필요할 때, |
  | watch     | data에서 정의한 속성이 변화했을 때 추가 동작을 수행할 수 있게 정의하는 속성<br />데이터 변화 자체가 trigger가 되는 methods를 정의할 경우 |
  | created   | 뷰의 라이프 사이클과 관련된 속성                             |
  | router    | new VueRouter를 등록하는 속성                                |

  - 컴포넌트 : 

    1. 구분

       전역컴포넌트 : Vue.component('컴포넌트명'. {컴포넌트내용})

       지역컴포넌트 : new Vue 내부에, 

       components :{

       ​	'컴포넌트명' : {

       ​		컴포넌트 내용

       ​	}

       }

    2. 컴포넌트간의 커뮤니케이션 

    - 컴포넌트간에 데이터 이동이 복잡해지면 관리가 어려움

    - 이를 위해 컴포넌트간의 데이터 통신규칙이 정해졌고, 이는 아래와 같다. 

      1. 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달한다.(Props)

      2. 하위 컴포넌트에서 상위 컴포넌트로는 이벤트가 올라간다. ($emit 이벤트)

    3. 컴포넌트 네이밍 컨벤션 종류
       1. 케밥케이스 표기법, vue.js 공식 스타일 가이드 상의 표기법이라고 함(확인해보기)
       2. 파스칼케이스 표기법
       3. 파스칼케이스 표기 + self-closing

  - Props

    Props는 상위 컴포넌트의 data를 하위 컴포넌트에서 활용할 수 있게 하는 데이터 전달 방식이다. 방법은 아래와 같다. 

    ```
    <div id="app">
    	<app-header></app-header>
    </div>
    
    
    const appHeader = {
    	template: '<h1>헤딩</h1>'
    }
    
    new Vue({
    	el : '#app',
    	components : {
    		'app-header' : appHeader
    	}
    	data : {
    		message: 'hi'
    	}
    })
    
    
    ```

    위 상황에서, new Vue로 시작되는 Root component의 data, message를 하위 component appHeader로 넘기기 위해서는

    1. 하위 컴포넌트에는 Props 속성 및 props data명을 추가한다.

    2. app-header 태그에서 Pros속성을 bind하고, 상위 컴포넌트에서의 data명을 병기한다.

       ```
       <div id="app">
       	<app-header :prosData='message'></app-header>
       </div>
       
       const appHeader = {
       	template: '<h1>헤딩</h1>',
       	props: ['propsdata']
       }
       
       ```

       =  상위데이터인 message는 app-header태그에 V-bind로 데이터를 공유할 수 있으며
       하위 컴포넌트에서는 props 속성을 활용하여 상위 데이터를 하위 컴포넌트에서 활용가능하게 한다.
       하위 컴포넌트의 템플릿에서는 'propsdata'를 해당 'props data명'으로 활용이 된다. 

  - computed

    data에 연계돼서 특정관계성에 의해 조작된 또 다른 data를 관리해야할 때 씀

    문법 : 

    ```
      computed: {
        kimin2(){
          return this.kimin * 3
        }
      },
    ```

    * 특이사항 : 
      1. 함수형태여야 한다.
      2. return 이 있어야 한다. 

  - watch

    data의 변화 자체를 trigger로 삼는 함수를 정의할 경우에 쓰이는 디렉토리

    data와 연계되기 때문에 watch의 함수명은 항상 data에 존재하는 data명과 동일할 것임을 추측함

    - 문법

    ```
      <script>
        new Vue({
          el: '#app',
          data: {
            num: 10
          },
          watch: {
            num: function() {
              this.logText();
            }
          },
          methods: {
            addNum: function() {
              this.num = this.num + 1;
            },
            logText: function() {
              console.log('changed');
            }
          }
        })
      </script>
    ```

    - watch와 computed의 차이점

      보통은 computed로 해결하면 되고 일부 watch가 필요한 특수상황에서 watch를 사용하자. 

      (computed는 해당 함수 1개로 해결)(watch는 watch 해당함수 1개, 관련 method 1개 총 2개 필요)

    

    

    - $emit

    $emit이라는 api가 있는데. 

    하위 component takeEvent라는 method가 있을 때, 해당 method에서 emit api를 실행한 다는 상황에서,

    ```
    <div id="app">
    	<app-header></app-header>
    </div> 
    
    const appHeader = {
    	template: `<button @click='takeEvent'>click!!!</button>`,
    	methods:{
    		takeEvent : function() {
    			this.emit("pass")
    		}
    	}
    }
    (new Vue 부분 생략)
    ```

    하위 컴포넌트에서 받은 'click'이벤트가 emit을 통해 상위컴포넌트에서 pass라는 이벤트로 공유받게 되고, pass 이벤트에 따른 상호작용을 위해 상위 컴포넌트가 이를 활용하는 method 'logText'를 등록하게 되면 아래와 같은 모양이 된다. 

    ```
    <div id="app">
    	<app-header @pass='logText'></app-header>
    </div> 
    (appHeader 생략)
    
    new Vue({
    	el: '#app',
    	components: {
    		'app-header' : appHeader
    	},
    	methods:{
    		logText = function(){
    			console.log("패스확인")
    		}
    	}
    })
    ```

    결론적으로 클릭에 의해 vue 개발자도구에 emit이벤트 'pass' '패스확인' 로그를 콘솔에서 확인할 수있는데, 

    이는 emit API로 인해 하위 컴포넌트 appHeader에서 발생한 click이벤트가 상위 컴포넌트에서 인지되게 되었음의 결과이다.

- 같은레벨에서의 컴포넌트 통신
  1. 기본원리 : 상위 컴포넌트로 event를 올리고 props속성으로 하위 컴포넌트로 내리는 2단계로 통신
  2. 보조개념 : emit, props,

​	1. emit을 통해 하위컴포넌트의 이벤트트리거가 상위 컴포넌트 이벤트로 전달될 수 있도록 하게 하는데, 이때, 

	2. this.$emit("event  Name", "전달변수") 이벤트만 올릴때와는 달리 데이터를 2번째 인자로 해서  emit을 실행한다. 
	2. 이렇게 하고 상위 컴포넌트에서는 @event Name='Event Name(전달변수)'라는구문을 통해 emit의 2번째 인자로 전달받은 data를 암묵적으로 접수한다.
	2. 상위 컴포넌트에서의 method Event Name(전달변수)을 정의할 때, 해당 변수의 handler를 등록하고,
	2. 마찬가지로 상위 컴포넌트에서의 data에서도 해당 변수를 등록하면 된다. 
	2. 또 다른 컴포넌트로 다시 props를 활용하여 data를 내린다. 

- router 

  new VueRouter로 생성되는 객체, VueRouter 라이브러리 별도 설치후에 생성이 가능함

  생성객체의 구성 속성은 아래와 같다. 

  1. routes (페이지별 라우팅 정보)

     여러개의 페이지정보를 배열정보로 담아내며, 각 페이지 정보는 객체로 정의됨, 객체별 구성정보는 'url', 'component'

     routes: [

     ​	{

     ​	path: '/login',  // 링크

     ​	component: 'loginComponent' // 불러올 컴포넌트

     ​	name: 'login' // vue 개발자도구에서 표현될 컴포넌트 이름

     },

     ​	{}

     ]

  2. mode 

     선택사항이며 mode : history 라고 추가시키면 url에서 #가 빠지는 모습으로 보이게 됨

  - routes의 사용

    - 상위 component에서 routes에 따라 페이지 컴포넌트를 불러들이는 방법은, 

      상위 component에서 <router-view></router-view>를 추가하면 됨

      <router-view>태그는 url 입력에 따른 해당 component를 불러오는 태그임.

    - <router-link>태그

      router-view component를 통해 페이지 이동을 하기 위해 직접 url을 입력하며 새 페이지를 불러올 수 있지만,

      클릭을 통해 url을 바꿀 수 있는 <a>태그가 있고 view에서 더 간단한 역할을 제공하는것이 <router-link>태그이다. 

      <router-link>는 VueRouter 라이브러리를 통해 브라우저에서는 <a>태그로 변환되는데, a태그와는 달리 페이지 이동이 아닌 싱글페이지어플리케이션 형태의 페이지 전환을 구현하게 해준다.

      링크는 to="" 속성에 적으면 되고, <a>태그의 href=""와 같은 역할이다. 

  - 추가적으로 공부해 볼 부분

    1. router navigation guard
    2. 인증

- 디렉티브 :디렉티브는 `v-` 접두사가 있는 특수 속성입니다. 디렉티브 속성 값은 **단일 JavaScript 표현식** 이 됩니다. (나중에 설명할 `v-for`는 예외입니다.) 디렉티브의 역할은 표현식의 값이 변경될 때 사이드이펙트를 반응적으로 DOM에 적용하는 것 입니다. 

  |         | 기능                    | 약어 | 문법/비고                                                    |
  | ------- | ----------------------- | ---- | ------------------------------------------------------------ |
  | v-bind  | (속성용)변수 바인딩     | :    | <span v-bind:title="message">                                |
  | v-if    | (조건문) 제거 또는 삽입 |      | <span v-if='status'> // status는  boolean으로..              |
  | v-for   | 배열데이터 바인딩       |      | <li v-for="todo in todos" :key=""><br/>      {{ todo.text }}<br/>    </li> |
  | v-on:   | 이벤트 핸들러           | @    | v-on:이벤트="함수명"<br />* .prevent를 붙여서 preventDefault를 수식가능 |
  | v-model | 변수 양방향 바인딩      |      |                                                              |
  | v-once  | 데이터 데이트 불가      |      |                                                              |
  | v-html  | 실제 html출력           |      |                                                              |
  | v-text  |                         |      |                                                              |

  - v-bind

    <. p :class={ cName : isError } >  </ p >

    

    v-bind의 문법중 하나는 중괄호로 bind값을 입력했을때, 우항이 true일때 좌항이 해당 속성값이 유효하다. 라는 문법이 있음

    

    

    
    
  - v-for 

    <a v-for="(a,i) in menuitems" :key="i"> {{a}} </a

     변수는 2개로 적을 수 있는데 i는 생략이 가능하다(a,i 부분)

    좌변은 해당 array의 각 변수, 우변은 index이다.(1씩 증가하는)

    중괄호에 i 를 넣으면 0 ~ array.length의 index 들이 찍힌다. 

    key의 역할은 "나중에 알아볼것" //인데 필요하든 안하든 무조건 적어주는게 문법이고 미기재하면 에러가 난다. 

    





## 75. 부모요소 / 자식요소 탐색

DOM 탐색 문법 정리(ing)

- sibling, previousElementSibling, nextSibling, 



1. 자바스크립트

   1. parentElement, parentNode

   2. Element.closest() : 부모요소 찾기용, 선택자 필수

   3. 일반 DOM  탐색 기능 활용(querySelector) : - 자식(~자손)찾기용

      querySelectorAll & getElementBy 도 마찬가지. 

   4. .children : 직속 자식 배열 

   5. childNodes : 직속 자식 '노드' 배열 

2. Jquery
   1. parent() : 직속 부모 확인
   2. parents() : 상위요소(부모 ~ 조상까지 전부) 전부
   3. closest() : 상위요소(부모 ~ 조상까지 전부)중에서, 가장 가까운 부모
   4. children() : 직속 자식 확인
   5. find()

​				children의 parents버전이라고 생각하면 될 듯 하다.

​				children이 직속 자식 레벨만 검색이 된다면 find는 최하우까지 자식 요소를 탐색할 수 있다. 

​				번거롭게 children 중첩을 해서 생 난리를 떨었는데 이제라도 알게돼서 다행이다. 

```
1. find 사용 전(children 중첩 )
const title = $($($(tr.children(".content")).children(".contentWrapper")).children(".title")).children().val();

2. find 사용
const title = 
tr.find(".title input").val()
```





## 76. 즉시 실행함수



"**즉시 실행 함수 표현(IIFE, Immediately Invoked Function Expression)**"

"표현 내부의 변수는 외부로부터의 접근이 불가능하다."

"괄호(`()`, Grouping Operator)로 둘러싸인 익명함수(Anonymous Function)이다. 이는 전역 스코프에 불필요한 변수를 추가해서 오염시키는 것을 방지할 수 있을 뿐 아니라 IIFE 내부안으로 다른 변수들이 접근하는 것을 막을 수 있는 방법이다."

"대부분의 Library들이 이런식으로 구성된 모양"

## 77.box-sizing

1. 기본적으로 요소의 크기는 margin,border, padding을 제외한 content의 크기를 말한다.
2. 이 때문에 의도치 않은 사이즈 조정이 일어날 수 있기에
3. box-sizing 속성이 개발되었다.
4. box-sizing속성의 값
   - content-box : 초기 값, content 사이즈만 사이즈로 인식 
   - border-box : border까지 포함한 사이즈가 사이즈인 것으로.

## 78. 생소한 태그속성 정리

**a 태그 - target**

링크된 문서를 클릭했을 때 문서가 열릴 위치를 명시합니다.

유효 태그 값 : blank|_self|_parent|_top|

|   속성값    |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|   _blank    |      링크된 문서를 새로운 윈도우나 탭(tab)에서 오픈함.       |
|    _self    | 링크된 문서를 링크가 위치한 현재 프레임에서 오픈함.기본값으로 생략 가능. |
|   _parent   |     링크된 문서를 현재 프레임의 부모 프레임에서 오픈함.      |
|    _top     |          링크된 문서를 현재 윈도우 전체에서 오픈함.          |
| 프레임 이름 |           링크된 문서를 명시된 프레임에서 오픈함.            |















































































[^1]: 버블링 : 이벤트 전달방식의 2가지 방법중 하위요소에서 상위요소로 향하는 방식
[^2]: https://ui.toast.com/weekly-pick/ko_20160826
[^3]: coalesce : 합치다.
[^4]: 예시 - function printText(x){const text = x ??0 "x가 null이거나,undefined임"; / n console.log(text)} // x를 콘솔에 출력하되, nullish면 에러메세지 출력
[^5]: 프로그래밍영역에서 **매핑**은 키(key) 역할을 하는 데이터와 값(value) 역할을 하는 데이터를 짝 지어(=연결 지어) 저장하는 데이터 구조를 말한다. 키는 저장된 데이터의 구별에, 값은 그 키와 연결되어 저장된 데이터를 뜻한다.

[^6]: Document Object Model?





